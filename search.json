[{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"dataset","dir":"Articles","previous_headings":"","what":"Dataset","title":"Cell states","text":"single-cell RNA sequencing dataset peripheral blood mononuclear cells (PBMCs) healthy versus COVID-19 infected donors published Wilk et al., (2020) used demonstrated cell cluster probability can used identify perturbed cell states associated differential gene expression programs. addition original cell type annotations, object provided contains cell type annotations given Välikangas et al., 2022. original dataset downsampled 21K cells (1.5K cells per sample; 44,721 cells) increase speed reduce computational resources required run vignette. facilitate reproduction vignette, data distributed Zenodo SingleCellExperiment object, object (class) required functions Coralysis (see Chapter 4 SingleCellExperiment class - OSCA manual)","code":"# Install packages  if (! \"scater\" %in% installed.packages()) pak::pkg_install(\"scater\") if (! \"ComplexHeatmap\" %in% installed.packages()) pak::pkg_install(\"ComplexHeatmap\")  # Import packages library(\"dplyr\") library(\"scater\") library(\"ggplot2\") library(\"Coralysis\") library(\"SingleCellExperiment\") # Import data  data.url <- \"https://zenodo.org/records/14845751/files/covid_Wilk_et_al.rds?download=1\" sce <- readRDS(file = url(data.url))  # Downsample every sample to 1.5K cells: 21K cells in total cells.by.donor <- split(x = colnames(sce), f = sce$Donor_full) ncells <- 1.5e3 set.seed(123) down.cells <- lapply(X = cells.by.donor, FUN = function(x) {     sample(x = x, size = ncells, replace = FALSE) }) down.cells <- unlist(down.cells) sce <- sce[,down.cells]"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"normalization","dir":"Articles","previous_headings":"","what":"Normalization","title":"Cell states","text":"Coralysis requires log-normalised data input. dataset previously normalised basic log-normalisation method Seurat. simple custom function can used perform Seurat (see NormalizeData). alternative, scran normalization can performed, particularly beneficial rare cell types exist (see following vignette).","code":"## Normalize the data # log1p normalization SeuratNormalisation <- function(object) {   # 'SeuratNormalisation()' function applies the basic Seurat normalization to   #a SingleCellExperiment object with a 'counts' assay. Normalized data   #is saved in the 'logcounts' assay.   logcounts(object) <- apply(counts(object), 2, function(x) {     log1p(x/sum(x)*10000)   }) # log1p normalization w/ 10K scaling factor   logcounts(object) <- as(logcounts(object), \"sparseMatrix\")   return(object) } sce <- SeuratNormalisation(object = sce) ## scran normalisation ScranNormalisation <- function(object) {     norm_clusters <- scran::quickCluster(object)     object <- scran::computeSumFactors(object, clusters = norm_clusters)     object <- scater::logNormCounts(object)     return(object) }  # Split object by batch: 'Donor_full' batch.levels <- levels(sce$Donor_full) names(batch.levels) <- batch.levels sce.list <- lapply(batch.levels, function(x) sce[,sce$Donor_full == x])  # Apply normalisation set.seed(123) sce.list <- lapply(sce.list, ScranNormalisation)  # Join  sce <- do.call(cbind, sce.list)"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"hvg-selection","dir":"Articles","previous_headings":"","what":"HVG selection","title":"Cell states","text":"Highly variable genes (HVG) can selected using R package scran. variable Donor_full colData used batch label. SingleCellExperiment object allows alternative experiments main experiment. important keep backup genes SingleCellExperiment object selecting HVGs (see SingleCellExperiment vignette).","code":"# Feature selection with 'scran' package nhvg <- 2000 batch.label <- \"Donor_full\" sce[[batch.label]] <- factor(sce[[batch.label]]) m.hvg <- scran::modelGeneVar(sce, block=sce[[batch.label]]) hvg.ordered <- order(m.hvg[[\"bio\"]], decreasing=TRUE) top.hvg <- row.names(sce)[hvg.ordered[1:nhvg]] rowData(sce) <- cbind(\"highly_variable\" = row.names(sce) %in% top.hvg, m.hvg)  # Subset object  sce <- sce[top.hvg,]"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"dimred-pre-integration","dir":"Articles","previous_headings":"","what":"DimRed: pre-integration","title":"Cell states","text":"PCA UMAP representation dataset performing integration can obtained Coralysis. Several parameters can provided functions order adjust analyses dataset (see ?Coralysis::RunPCA() ?Coralysis::RunUMAP).  clear donor effect, particularly cell types, CD14 monocytes CD8 memory T cells.","code":"# Dimensional reduction - unintegrated set.seed(123) sce <- RunPCA(object = sce, assay.name = \"logcounts\", dimred.name = \"unintPCA\") set.seed(123) sce <- RunUMAP(object = sce, dims = 1:30, dimred.type = \"unintPCA\",                 umap.method = \"uwot\", dimred.name = \"unintUMAP\",                 n_neighbors = 15, min_dist = 0.3) # Plotting  batch.label <- \"Donor_full\" original.cell.label <- \"cell_type\" cell.label <- \"predicted_celltype_l2\" vars2plot <- c(batch.label, original.cell.label, cell.label) names(vars2plot) <- vars2plot unint.plts <- lapply(X = vars2plot, FUN = function(x) {     PlotDimRed(object = sce, color.by = x, dimred = \"unintUMAP\", point.size = 0.2,                 legend.nrow = 10, point.stroke = 0.1) }) # plot each variable all.unint.plts <- cowplot::plot_grid(plotlist = unint.plts, ncol = 3, align = \"vh\") # join plots together all.unint.plts"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"multi-level-integration","dir":"Articles","previous_headings":"","what":"Multi-level integration","title":"Cell states","text":"Multi-level integration can performed Coralysis running function RunParallelDivisiveICP(). batch.label parameter required. batch.label corresponds variable colData. case Donor_full. RunParallelDivisiveICP() function can run parallel providing number threads reduce run time (takes around 25 min. ICP batch size 1K cells 4 threads). Consult full documentation function ?RunParallelDivisiveICP. Coralysis returns list cell cluster probabilities saved metadata(sce)$coralysis$joint.probability length equal number icp runs, .e., L (default L=50), times number icp rounds, .e., log2(k) (default k=16, thus 4 rounds divisive icp).","code":"# Perform multi-level integration set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"Donor_full\",                                icp.batch.size = 1000, threads = 4)"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"icp-clusters","dir":"Articles","previous_headings":"","what":"ICP clusters","title":"Cell states","text":"cell cluster probability given icp run divisive rounds can plotted function PlotClusterTree(). colData variable can provided see composition per cluster across divisive rounds respective icp run. See examples icp run number 16.  cell types formed unique clusters, quite remained mixed. Multi-level integration resolution might get better running RunParallelDivisiveICP() 32 cluster, .e., k = 32, instead 16.","code":"## Plot cluster tree for icp run 16 # Probability prob.cluster.tree <- PlotClusterTree(object = sce, icp.run = 16)  # batch label distribution batch.cluster.tree <- PlotClusterTree(object = sce, icp.run = 16, color.by = \"Donor_full\")  # original cell type label distribution orig.cell.cluster.tree <- PlotClusterTree(object = sce, icp.run = 16, color.by = \"cell_type\")  # Azimuth/predicted cell type label distribution cell.cluster.tree <- PlotClusterTree(object = sce, icp.run = 16, color.by = \"predicted_celltype_l2\")  # Join all plots with 'cowplot' all.cluster.tree <- cowplot::plot_grid(cowplot::plot_grid(prob.cluster.tree, batch.cluster.tree,                                                            ncol = 2, rel_widths = c(0.5, 0.5), align = \"v\"),                                         cowplot::plot_grid(orig.cell.cluster.tree, cell.cluster.tree,                                                            ncol = 2, rel_widths = c(0.5, 0.5), align = \"vh\"),                                        ncol = 1) all.cluster.tree"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"dimred-after-integration","dir":"Articles","previous_headings":"","what":"DimRed: after integration","title":"Cell states","text":"Coralysis returns list cell cluster probabilities saved metadata(sce)$coralysis$joint.probability length equal number icp runs, .e., L (default L=50), times number icp rounds, .e., log2(k) (default k=16, thus 4 rounds divisive icp). cell cluster probability can concatenated compute PCA order obtain integrated embedded. default cell cluster probability corresponding last icp round used. Coralysis integrated embedding can used downstream non-linear dimensional reduction, t-SNE UMAP, clustering.  Coralysis efficiently integrated donor PBMC samples, identified small populations (e.g., neutrophils, Treg, MAIT, dnT, NK CD56bright), differentiation trajectories (e.g., B naive memory).","code":"# Dimensional reduction - unintegrated set.seed(123) sce <- RunPCA(object = sce, assay.name = \"joint.probability\", dimred.name = \"intPCA\")  # UMAP set.seed(123) sce <- RunUMAP(object = sce, dimred.type = \"intPCA\",                 umap.method = \"uwot\", dimred.name = \"intUMAP\",                 dims = 1:30, n_neighbors = 15, min_dist = 0.3) # Plotting  int.plts <- lapply(X = vars2plot, FUN = function(x) {     PlotDimRed(object = sce, color.by = x, dimred = \"intUMAP\", point.size = 0.2, legend.nrow = 10, point.stroke = 0.1) }) # plot each variable all.int.plts <- cowplot::plot_grid(plotlist = int.plts, ncol = 3, align = \"vh\") # join plots together all.int.plts"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"graph-based-clustering","dir":"Articles","previous_headings":"","what":"Graph-based clustering","title":"Cell states","text":"Graph-based clustering can obtained running scran function clusterCells() using Coralysis integrated embedding. alternative, joint cluster probabilities can used clustering. advantages using integrated embedding instead joint probabilities : computational efficiency; , noise robustness. Using joint probabilities instead PCA embedding takes considerably time.","code":"### Graph-based clustering with scran ## Coralysis integrated PCA embedding  reducedDim(sce, \"cltPCA\") <- reducedDim(sce, \"intPCA\")[,1:30] set.seed(1024) sce$emb_clusters <- scran::clusterCells(sce, use.dimred = \"cltPCA\",                                          BLUSPARAM = bluster::SNNGraphParam(k = 15, cluster.fun = \"louvain\"))  ## Coralysis joint cluster probabilities # retrieve ICP cell cluster probability tables for every icp run, but only for the last divisive round probs <- GetCellClusterProbability(object = sce, icp.round = 4)  # dim(probs) # 21K cells x 800 clusters (16 clusters x 50 icp runs = 800 clusters)  probs <- t(probs) colnames(probs) <- colnames(sce) prob.sce <- SingleCellExperiment(assays = list(\"probability\" = probs)) set.seed(1024) sce$prob_clusters <- scran::clusterCells(prob.sce,                                           assay.type = \"probability\",                                          BLUSPARAM = bluster::SNNGraphParam(k = 15, cluster.fun = \"louvain\")) # Plotting vars2plot2 <- c(cell.label, \"emb_clusters\", \"prob_clusters\") names(vars2plot2) <- vars2plot2 clts.plts <- lapply(X = vars2plot2, FUN = function(x) {     PlotDimRed(object = sce, dimred = \"intUMAP\", color.by = x, point.size = 0.2, legend.nrow = 10, point.stroke = 0.1) }) # plot each variable all.clts.plts <- cowplot::plot_grid(plotlist = clts.plts, ncol = 3, align = \"vh\") # join plots together all.clts.plts"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"cell-state-identification","dir":"Articles","previous_headings":"","what":"Cell state identification","title":"Cell states","text":"cell cluster probability aggregated mean median across icp runs can obtained function SummariseCellClusterProbability() plotted infer transient steady cell states.  instance, B cell states (naive, intermediate, memory) well supported Coralysis cell cluster probability, probably require run Coralysis higher resolution, .e., k=32 instead k=16.","code":"# Summarise cell cluster probability sce <- SummariseCellClusterProbability(object = sce, icp.round = 4) # save result in 'colData' # colData(sce) # check the colData # Plot cell cluster probabilities - mean # possible options: \"mean_probs\", \"median_probs\", \"scaled_median_probs\"  PlotExpression(object = sce, color.by = \"scaled_mean_probs\", dimred = \"intUMAP\", color.scale = \"viridis\",                 point.size = 0.2, point.stroke = 0.1, legend.title = \"Mean prob.\\n(min-max)\")"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"gene-coefficients","dir":"Articles","previous_headings":"","what":"Gene coefficients","title":"Cell states","text":"Gene coefficients can obtained given cell label majority voting function MajorityVotingFeatures(). majority voting performed searching representative cluster given cell label across possible clusters (.e., across icp runs rounds). representative cluster corresponds cluster highest majority voting score. corresponds geometric mean proportion cells given label intersected cluster proportion cells cluster intersected cells given label. higher score better. cluster scores 1 indicates cells correspond assigned label, vice versa; .e., cells assigned label belong cluster. example, MajorityVotingFeatures() providing colData variable \"emb_clusters\"(.e., label=\"emb_clusters\"). function MajorityVotingFeatures() returns list two elements: feature_coeff: list data frames comprising gene coefficients respective weights. summary: data frame summarizing ICP cluster best represents cell label, along respective majority voting score.","code":"# Get label gene coefficients by majority voting clts.gene.coeff <- MajorityVotingFeatures(object = sce, label = \"emb_clusters\") # Print cluster gene coefficients summary clts.gene.coeff$summary ##    label icp_run icp_round cluster     score ## 1      1      22         4       8 0.8157863 ## 2      2      24         4      16 0.9421878 ## 3      3      21         4      11 0.5959206 ## 4      4      21         4      14 0.6799433 ## 5      5      29         4       7 0.6721712 ## 6      6      48         4      11 0.7086803 ## 7      7      36         4      14 0.4917519 ## 8      8      16         4       2 0.8996775 ## 9      9      22         4       7 0.5562097 ## 10    10      47         4      16 0.6487200 ## 11    11      19         4       4 0.9326988 ## 12    12      24         4       9 0.5858352 ## 13    13      21         4       2 0.7723912 ## 14    14      41         4       6 0.8999670 ## 15    15      37         4       3 0.8040199 ## 16    16      29         4      10 0.6894886 ## 17    17      48         4      12 0.9532055 ## 18    18      46         4       5 0.7898323 ## 19    19      18         4      10 0.6683786 ## 20    20      20         4       7 0.9176726 ## 21    21      31         4       1 0.8014923"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"unique-marker-prss23","dir":"Articles","previous_headings":"Gene coefficients","what":"Unique marker: PRSS23","title":"Cell states","text":"One strengths Coralyis consist finding unique cluster markers case cluster 2.","code":"# Print top 30 positive gene coefficients for cluster 2: NK + CD8 TEM  head(clts.gene.coeff$feature_coeff$`2`[order(clts.gene.coeff$feature_coeff$`2`[,2], decreasing = TRUE),], 30) ##     feature   coeff_clt16 ## 43   PRSS23  4.3504965756 ## 18     GZMB  0.1637480659 ## 19     GZMH  0.1308493859 ## 79   ZBTB44  0.1109175583 ## 40    PATL2  0.0983686833 ## 72    TBX21  0.0954275398 ## 7     CD247  0.0753691598 ## 15     GNLY  0.0730897748 ## 61    RUNX3  0.0686593222 ## 39    PARP8  0.0654860566 ## 42     PRF1  0.0504557585 ## 8      CDK6  0.0427174844 ## 27    KLRD1  0.0402690820 ## 17     GZMA  0.0375472215 ## 46      PXN  0.0360506239 ## 14     GNG2  0.0223021975 ## 25   IPCEF1  0.0156802538 ## 45   PTGER4  0.0087374973 ## 6      CCL5  0.0082154040 ## 47    RBM27  0.0031892948 ## 80     ZEB2  0.0018210680 ## 69  ST3GAL1 -0.0005403014 ## 12   GIMAP4 -0.0008745088 ## 68  SMARCA2 -0.0013411496 ## 21 HSP90AB1 -0.0020678336 ## 75   TMSB4X -0.0027057304 ## 51    RPL34 -0.0032341377 ## 57     RPS3 -0.0033493263 ## 4     BIRC6 -0.0040249087 ## 2      ACTB -0.0047227878 # Plot the expression of PRSS23 PlotExpression(sce, color.by = \"PRSS23\", dimred = \"intUMAP\", point.size = 0.5, point.stroke = 0.5)"},{"path":[]},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"cd14-mono-1-vs-5","dir":"Articles","previous_headings":"Cluster markers","what":"CD14 Mono: 1 vs 5","title":"Cell states","text":"Coralysis identified three main clusters CD14 monocytes: 1 (2,028 cells), 5 (1,651), 9 (935) (considering Louvain clustering obtained integrated embedding). clusters 1 compared 5 .   expression level CYP1B1 cluster 1 slightly higher COVID-19 infected donor cells healthy donors, particularly, ventilated versus healthy donors.   previous plots suggest clusters 1 5 phenotypically different. addition, low expression HLA-DR (HLA-DRA, HLA-DRB1) genes associated severe inflammatory conditions like COVID-19 (see plots ) well high expression S100A9. results suggest cluster 1 corresponds strongly activated possibly dysregulated monocytes, common severe COVID-19 cluster 5. Indeed, 40% cells cluster 1 COVID-19 infected donors required ventilation, whereas percentage around 25% cluster 5.","code":"# Cluster gene coefficients: 1 versus 8 clt1 <- clts.gene.coeff$feature_coeff$`1` clt1 <- clt1[order(clt1[,2], decreasing = TRUE),] clt5 <- clts.gene.coeff$feature_coeff$`5` clt5 <- clt5[order(clt5[,2], decreasing = TRUE),]  # Merge cluster coefficients clt1vs5 <- merge(clt1, clt5, all = TRUE) clt1vs5[is.na(clt1vs5)] <- 0 clt1vs5.parsed <- clt1vs5 %>%      mutate(\"coeff_variation\" = abs(coeff_clt7 - coeff_clt8)) %>%      arrange(desc(coeff_variation)) %>%      filter(coeff_clt7!=0 & coeff_clt8!=0) %>%      filter((coeff_clt7 * coeff_clt8)<0) top5.clt1 <- clt1vs5.parsed  %>%      arrange(desc(coeff_clt8)) %>%     pull(feature) %>% head(5) top5.clt5 <- clt1vs5.parsed %>%      arrange(desc(coeff_clt7)) %>%      pull(feature) %>% head(5)  # Top 5 positive coefficients in each cluster top5.genes <- c(top5.clt1, top5.clt5) names(top5.genes) <- top5.genes  # Plot top5.gexp.mono.clts.plts <- lapply(X = top5.genes, FUN = function(x) {     PlotExpression(object = sce, color.by = x, dimred = \"intUMAP\",                     scale.values = TRUE, point.size = 0.25, point.stroke = 0.25) }) all.top5.gexp.mono.clts.plts <- cowplot::plot_grid(plotlist = top5.gexp.mono.clts.plts, ncol = 5, align = \"vh\") all.top5.gexp.mono.clts.plts scater::plotExpression(object = sce[,sce$emb_clusters==\"1\"], features = \"CYP1B1\",                         color_by = \"Ventilated\", x = \"Ventilated\") genes2plot <- c(\"HLA-DRA\", \"HLA-DRB1\") gexp.hla.plots <- lapply(genes2plot, function(x) {     PlotExpression(object = sce, color.by = x, dimred = \"intUMAP\",                      scale.values = TRUE, point.size = 0.25, point.stroke = 0.25) }) cowplot::plot_grid(plotlist = gexp.hla.plots, ncol = 2, align = \"vh\")"},{"path":[]},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"cd16-monocytes","dir":"Articles","previous_headings":"Perturbed cell states","what":"CD16 Monocytes","title":"Cell states","text":"cell cluster probability can used search altered cell states, e.g., associated COVID-19. distribution cell cluster probability per cluster (integrated embedding) per ventilated group shown running function CellClusterProbabilityDistribution(). Cluster 14, roughly corresponding CD16 monocytes, shows difference healthy COVID associated cells (non-ventilated ventilated donor cells).   Cell cluster probability bins per cluster label can obtained running BinCellClusterProbability(), returns SingleCellExperiment object logcounts average per label per cell probability bin. number probability bins can provided parameter bins. cell frequency per cell bin per group interest can obtained function TabulateCellBinsByGroup(). heatmap shows cell frequency across ventilated groups per bins cluster 14 (corresponding CD16 monocytes). cell frequency represented corresponds cell proportions per group (healthy, non-ventilated ventilated) scaled bins, .e., columns. Cell states higher probabilities tend “healthier” states lower probabilities.  correlation cell cluster probability bins cluster 18 averaged gene expression can obtained function CellBinsFeatureCorrelation(). Among several positively negatively correlated genes, expression C1QB seems enriched diseased cells, negative Pearson coefficient close 0.7. gene selected example due expression relatively limited cluster 14.","code":"## Disease associated cell state  # Search for diseased affected cell states prob.dist <- CellClusterProbabilityDistribution(object = sce,                                                  label = \"emb_clusters\",                                                  group = \"Ventilated\",                                                  probability = \"scaled_mean_probs\") prob.dist # cell states SCE object  cellstate.sce <- BinCellClusterProbability(object = sce, label = \"emb_clusters\", icp.round = 4, bins = 20)   # Tabulate cell bins by group  cellbins.tables <- TabulateCellBinsByGroup(object = cellstate.sce, group = \"Ventilated\", relative = TRUE, margin = 1)  # Heatmap of cell bins distribution by group for cluster 20 - CD16 Monocytes cluster <- \"14\" col.fun <- circlize::colorRamp2(c(-1.5, 0, 1.5), viridis::inferno(3)) heat.plot <- ComplexHeatmap::Heatmap(matrix = scale(cellbins.tables[[cluster]]),                                       name = \"Col. Z-score\",                                       cluster_rows = FALSE,                                       cluster_columns = FALSE,                                       row_names_side = \"left\",                                       col = col.fun,                                       column_title = \"Distribution of cells per cell cluster probability bin\",                                       heatmap_legend_param = list(legend_direction = \"horizontal\",                                                                   title_position = \"topcenter\")) ComplexHeatmap::draw(heat.plot, heatmap_legend_side = \"bottom\", annotation_legend_side = \"bottom\") # Pearson correlated features with cluster 24 cor.features.clt14 <- CellBinsFeatureCorrelation(object = cellstate.sce, labels = cluster) cor.features.clt14 <- cor.features.clt14 %>%     filter(!is.na(`14`)) %>%      arrange(`14`) # C1QB exp.C1QB.umap <- PlotExpression(sce, color.by = \"C1QB\", dimred = \"intUMAP\",                                  scale.values = TRUE, point.size = 0.75, point.stroke = 0.25) exp.C1QB.violin <- scater::plotExpression(sce[,sce$emb_clusters == cluster], features = \"C1QB\",                                           x = \"Ventilated\", color_by = \"Ventilated\") exp.C1QB.umap exp.C1QB.violin"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"r-session","dir":"Articles","previous_headings":"","what":"R session","title":"Cell states","text":"","code":"# R session sessionInfo() ## R version 4.4.2 (2024-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.1 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] Coralysis_1.0.0             scater_1.34.0               ##  [3] ggplot2_3.5.1               scuttle_1.16.0              ##  [5] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0 ##  [7] Biobase_2.66.0              GenomicRanges_1.58.0        ##  [9] GenomeInfoDb_1.42.3         IRanges_2.40.1              ## [11] S4Vectors_0.44.0            BiocGenerics_0.52.0         ## [13] MatrixGenerics_1.18.1       matrixStats_1.5.0           ## [15] dplyr_1.1.4                 ##  ## loaded via a namespace (and not attached): ##   [1] RColorBrewer_1.1-3       shape_1.4.6.1            jsonlite_1.8.9           ##   [4] magrittr_2.0.3           modeltools_0.2-23        ggbeeswarm_0.7.2         ##   [7] farver_2.1.2             rmarkdown_2.29           GlobalOptions_0.1.2      ##  [10] fs_1.6.5                 zlibbioc_1.52.0          ragg_1.3.3               ##  [13] vctrs_0.6.5              Cairo_1.6-2              htmltools_0.5.8.1        ##  [16] S4Arrays_1.6.0           BiocNeighbors_2.0.1      SparseArray_1.6.1        ##  [19] sass_0.4.9               bslib_0.9.0              desc_1.4.3               ##  [22] plyr_1.8.9               cachem_1.1.0             igraph_2.1.4             ##  [25] lifecycle_1.0.4          iterators_1.0.14         pkgconfig_2.0.3          ##  [28] rsvd_1.0.5               Matrix_1.7-1             R6_2.6.0                 ##  [31] fastmap_1.2.0            clue_0.3-66              GenomeInfoDbData_1.2.13  ##  [34] aricode_1.0.3            digest_0.6.37            colorspace_2.1-1         ##  [37] dqrng_0.4.1              RSpectra_0.16-2          irlba_2.3.5.1            ##  [40] textshaping_1.0.0        beachmat_2.22.0          labeling_0.4.3           ##  [43] httr_1.4.7               polyclip_1.10-7          abind_1.4-8              ##  [46] compiler_4.4.2           rngtools_1.5.2           doParallel_1.0.17        ##  [49] withr_3.0.2              BiocParallel_1.40.0      viridis_0.6.5            ##  [52] ggforce_0.4.2            LiblineaR_2.10-24        MASS_7.3-61              ##  [55] DelayedArray_0.32.0      rjson_0.2.23             bluster_1.16.0           ##  [58] tools_4.4.2              vipor_0.4.7              beeswarm_0.4.0           ##  [61] scatterpie_0.2.4         flexclust_1.4-2          glue_1.8.0               ##  [64] grid_4.4.2               cluster_2.1.6            reshape2_1.4.4           ##  [67] generics_0.1.3           snow_0.4-4               gtable_0.3.6             ##  [70] class_7.3-22             tidyr_1.3.1              BiocSingular_1.22.0      ##  [73] ScaledMatrix_1.14.0      metapod_1.14.0           XVector_0.46.0           ##  [76] ggrepel_0.9.6            RANN_2.6.2               foreach_1.5.2            ##  [79] pillar_1.10.1            stringr_1.5.1            yulab.utils_0.2.0        ##  [82] limma_3.62.2             circlize_0.4.16          tweenr_2.0.3             ##  [85] lattice_0.22-6           SparseM_1.84-2           tidyselect_1.2.1         ##  [88] ComplexHeatmap_2.22.0    locfit_1.5-9.11          knitr_1.49               ##  [91] gridExtra_2.3            edgeR_4.4.2              xfun_0.50                ##  [94] statmod_1.5.0            pheatmap_1.0.12          stringi_1.8.4            ##  [97] UCSC.utils_1.2.0         ggfun_0.1.8              yaml_2.3.10              ## [100] evaluate_1.0.3           codetools_0.2-20         tibble_3.2.1             ## [103] cli_3.6.4                systemfonts_1.2.1        munsell_0.5.1            ## [106] jquerylib_0.1.4          Rcpp_1.0.14              doSNOW_1.0.20            ## [109] png_0.1-8                ggrastr_1.0.2            parallel_4.4.2           ## [112] pkgdown_2.1.1            doRNG_1.8.6.1            scran_1.34.0             ## [115] sparseMatrixStats_1.18.0 viridisLite_0.4.2        scales_1.3.0             ## [118] purrr_1.0.4              crayon_1.5.3             GetoptLong_1.0.5         ## [121] rlang_1.1.5              cowplot_1.1.3"},{"path":"https://elolab.github.io/Coralysis/articles/CellState.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Cell states","text":"Amezquita R, Lun , Becht E, Carey V, Carpp L, Geistlinger L, Marini F, Rue-Albrecht K, Risso D, Soneson C, Waldron L, Pages H, Smith M, Huber W, Morgan M, Gottardo R, Hicks S (2020). “Orchestrating single-cell analysis Bioconductor.” Nature Methods, 17, 137-145. https://www.nature.com/articles/s41592-019-0654-x. Gu, Z. (2022) “Complex heatmap visualization.” iMeta. 1(3):e43. doi: 10.1002/imt2.43. Lun ATL, McCarthy DJ, Marioni JC (2016). “step--step workflow low-level analysis single-cell RNA-seq data Bioconductor.” F1000Res., 5, 2122. doi:10.12688/f1000research.9501.2. McCarthy DJ, Campbell KR, Lun ATL, Willis QF (2017). “Scater: pre-processing, quality control, normalisation visualisation single-cell RNA-seq data R.” Bioinformatics, 33, 1179-1186. doi:10.1093/bioinformatics/btw777. Sousa , Smolander J, Junttila S, Elo L (2025). “Coralysis enables sensitive identification imbalanced cell types states single-cell data via multi-level integration.” bioRxiv. doi:10.1101/2025.02.07.637023 Wickham H (2016). “ggplot2: Elegant Graphics Data Analysis.” Springer-Verlag New York.","code":""},{"path":"https://elolab.github.io/Coralysis/articles/Coralysis.html","id":"dataset","dir":"Articles","previous_headings":"","what":"Dataset","title":"Get started","text":"quickly illustrate multi-level integration algorithm, use vignette two 10X PBMCs (Peripheral Blood Mononuclear Cells) 3’ assays: V1 V2. datasets downloaded 10X website. PBMC dataset V1 corresponds sample pbmc6k V2 pbmc8k: V1: pbmc6k V2: pbmc8k  Cells annotated using annotations provided Korsunsky et al., 2019 (Source Data Figure 4 file). overall data downsampled 2K cells (1K per assay) 2K highly variable genes selected scran R package. facilitate reproduction vignette, data distributed Zenodo SingleCellExperiment object, object (class) required functions Coralysis (see Chapter 4 SingleCellExperiment class - OSCA manual). SCE object provided comprises counts (raw count data), logcounts (log-normalized data) cell colData (includes batch cell labels, designated batch cell_type, respectively). Run code import R packages data required reproduce vignette.","code":"# Import packages library(\"Coralysis\") library(\"SingleCellExperiment\") # Import data from Zenodo data.url <- \"https://zenodo.org/records/14871436/files/pbmc_10Xassays.rds?download=1\" pbmc_10Xassays <- readRDS(file = url(data.url)) pbmc_10Xassays # print SCE object ## class: SingleCellExperiment  ## dim: 2000 2000  ## metadata(0): ## assays(2): counts logcounts ## rownames(2000): LYZ S100A9 ... IGSF8 KIR2DL1 ## rowData names(8): highly_variable mean ... FDR per.block ## colnames(2000): ACATACCTGTCAAC ATTGAAACTCGTAG ... AGAGTGGCAGGGTTAG ##   GACTGCGAGCGTTCCG ## colData names(3): barcode batch cell_type ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0):"},{"path":"https://elolab.github.io/Coralysis/articles/Coralysis.html","id":"preprocess","dir":"Articles","previous_headings":"","what":"Preprocess","title":"Get started","text":"PrepareData() function checks whether sparse matrix available logcounts assay (corresponds log-normalized data) removes non-expressed features.","code":"# Prepare data:  #checks 'logcounts' format & removes non-expressed genes pbmc_10Xassays <- PrepareData(object = pbmc_10Xassays) ## Data in `logcounts` slot already of `dgCMatrix` class... ## 2000/2000 features remain after filtering features with only zero values."},{"path":"https://elolab.github.io/Coralysis/articles/Coralysis.html","id":"multi-level-integration","dir":"Articles","previous_headings":"","what":"Multi-level integration","title":"Get started","text":"multi-level integration algorithm implemented RunParallelDivisiveICP() function, main function Coralysis. requires SingleCellExperiment object, case pbmc_10Xassays. perform integration across batch, batch.label available colData(pbmc_10Xassays) must provided. case, \"batch\". ensemble algorithm runs 50 times default, illustrative purposes, reduced 10 (L=10). Two threads allocated speed process (threads=2), though default, function uses available system threads. Specify one thread prefer use additional threads. result consists set models respective probability matrices (n = 40; log2(k) * L), stored metadata(pbmc_10Xassays)$coralysis$models metadata(pbmc_10Xassays)$coralysis$joint.probability, respectively.","code":"# Multi-level integration set.seed(123) pbmc_10Xassays <- RunParallelDivisiveICP(object = pbmc_10Xassays,                                           batch.label = \"batch\",                                           L = 10, threads = 2) ##  ## Building training set... ## Training set successfully built. ##  ## Computing cluster seed. ##  ## Initializing divisive ICP clustering... ##   |                                                                              |                                                                      |   0%  |                                                                              |========                                                              |  11%  |                                                                              |================                                                      |  22%  |                                                                              |=======================                                               |  33%  |                                                                              |===============================                                       |  44%  |                                                                              |=======================================                               |  56%  |                                                                              |===============================================                       |  67%  |                                                                              |======================================================                |  78%  |                                                                              |==============================================================        |  89%  |                                                                              |======================================================================| 100% ##  ## Divisive ICP clustering completed successfully. ##  ## Predicting cell cluster probabilities using ICP models... ## Prediction of cell cluster probabilities completed successfully. ##  ## Multi-level integration completed successfully."},{"path":"https://elolab.github.io/Coralysis/articles/Coralysis.html","id":"integrated-embedding","dir":"Articles","previous_headings":"","what":"Integrated embedding","title":"Get started","text":"integrated result Coralysis consist integrated embedding can obtained running function RunPCA. integrated PCA can, turn, used downstream clustering non-linear dimensional reduction techniques, RunTSNE RunUMAP. function RunPCA runs default PCA method implemented R package irlba (pca.method=\"irlba\"), requires seed ensure PCA result.","code":"# Integrated embedding set.seed(125) pbmc_10Xassays <- RunPCA(object = pbmc_10Xassays) ## Divisive ICP: selecting ICP tables multiple of 4"},{"path":"https://elolab.github.io/Coralysis/articles/Coralysis.html","id":"umap","dir":"Articles","previous_headings":"","what":"UMAP","title":"Get started","text":"Compute UMAP running function RunUMAP().","code":"# UMAP set.seed(1204) pbmc_10Xassays <- RunUMAP(object = pbmc_10Xassays)"},{"path":"https://elolab.github.io/Coralysis/articles/Coralysis.html","id":"visualize-batch-cell-types","dir":"Articles","previous_headings":"UMAP","what":"Visualize batch & cell types","title":"Get started","text":"Finally, integration can visually inspected highlighting batch cell type labels UMAP projection.","code":"# Visualize categorical variables integrated emb.  vars <- c(\"batch\", \"cell_type\") plots <- lapply(X = vars, FUN = function(x) {     PlotDimRed(object = pbmc_10Xassays, color.by = x,                 point.size = 0.25, point.stroke = 0.5,                 legend.nrow = 3) })  cowplot::plot_grid(plotlist = plots, ncol = 2, align = \"vh\") # join plots together"},{"path":"https://elolab.github.io/Coralysis/articles/Coralysis.html","id":"r-session","dir":"Articles","previous_headings":"","what":"R session","title":"Get started","text":"","code":"# R session sessionInfo() ## R version 4.4.2 (2024-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.1 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0 ##  [3] Biobase_2.66.0              GenomicRanges_1.58.0        ##  [5] GenomeInfoDb_1.42.3         IRanges_2.40.1              ##  [7] S4Vectors_0.44.0            BiocGenerics_0.52.0         ##  [9] MatrixGenerics_1.18.1       matrixStats_1.5.0           ## [11] Coralysis_1.0.0             ##  ## loaded via a namespace (and not attached): ##   [1] rlang_1.1.5              magrittr_2.0.3           flexclust_1.4-2          ##   [4] compiler_4.4.2           png_0.1-8                systemfonts_1.2.1        ##   [7] vctrs_0.6.5              reshape2_1.4.4           stringr_1.5.1            ##  [10] pkgconfig_2.0.3          crayon_1.5.3             fastmap_1.2.0            ##  [13] XVector_0.46.0           labeling_0.4.3           scuttle_1.16.0           ##  [16] rmarkdown_2.29           ggbeeswarm_0.7.2         UCSC.utils_1.2.0         ##  [19] ragg_1.3.3               xfun_0.50                modeltools_0.2-23        ##  [22] bluster_1.16.0           zlibbioc_1.52.0          cachem_1.1.0             ##  [25] beachmat_2.22.0          jsonlite_1.8.9           DelayedArray_0.32.0      ##  [28] BiocParallel_1.40.0      irlba_2.3.5.1            parallel_4.4.2           ##  [31] aricode_1.0.3            cluster_2.1.6            R6_2.6.0                 ##  [34] bslib_0.9.0              stringi_1.8.4            RColorBrewer_1.1-3       ##  [37] reticulate_1.40.0        limma_3.62.2             jquerylib_0.1.4          ##  [40] Rcpp_1.0.14              iterators_1.0.14         knitr_1.49               ##  [43] snow_0.4-4               Matrix_1.7-1             igraph_2.1.4             ##  [46] tidyselect_1.2.1         abind_1.4-8              yaml_2.3.10              ##  [49] codetools_0.2-20         doRNG_1.8.6.1            lattice_0.22-6           ##  [52] tibble_3.2.1             plyr_1.8.9               withr_3.0.2              ##  [55] askpass_1.2.1            ggrastr_1.0.2            evaluate_1.0.3           ##  [58] desc_1.4.3               pillar_1.10.1            rngtools_1.5.2           ##  [61] foreach_1.5.2            generics_0.1.3           ggplot2_3.5.1            ##  [64] sparseMatrixStats_1.18.0 munsell_0.5.1            scales_1.3.0             ##  [67] class_7.3-22             glue_1.8.0               metapod_1.14.0           ##  [70] pheatmap_1.0.12          LiblineaR_2.10-24        tools_4.4.2              ##  [73] BiocNeighbors_2.0.1      ScaledMatrix_1.14.0      SparseM_1.84-2           ##  [76] RSpectra_0.16-2          locfit_1.5-9.11          RANN_2.6.2               ##  [79] fs_1.6.5                 scran_1.34.0             Cairo_1.6-2              ##  [82] cowplot_1.1.3            grid_4.4.2               umap_0.2.10.0            ##  [85] edgeR_4.4.2              colorspace_2.1-1         GenomeInfoDbData_1.2.13  ##  [88] beeswarm_0.4.0           BiocSingular_1.22.0      vipor_0.4.7              ##  [91] cli_3.6.4                rsvd_1.0.5               textshaping_1.0.0        ##  [94] S4Arrays_1.6.0           dplyr_1.1.4              doSNOW_1.0.20            ##  [97] gtable_0.3.6             sass_0.4.9               digest_0.6.37            ## [100] SparseArray_1.6.1        dqrng_0.4.1              farver_2.1.2             ## [103] htmltools_0.5.8.1        pkgdown_2.1.1            lifecycle_1.0.4          ## [106] httr_1.4.7               statmod_1.5.0            openssl_2.3.2"},{"path":"https://elolab.github.io/Coralysis/articles/Coralysis.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Get started","text":"Amezquita R, Lun , Becht E, Carey V, Carpp L, Geistlinger L, Marini F, Rue-Albrecht K, Risso D, Soneson C, Waldron L, Pages H, Smith M, Huber W, Morgan M, Gottardo R, Hicks S (2020). “Orchestrating single-cell analysis Bioconductor.” Nature Methods, 17, 137-145. https://www.nature.com/articles/s41592-019-0654-x. Sousa , Smolander J, Junttila S, Elo L (2025). “Coralysis enables sensitive identification imbalanced cell types states single-cell data via multi-level integration.” bioRxiv. doi:10.1101/2025.02.07.637023","code":""},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"dataset","dir":"Articles","previous_headings":"","what":"Dataset","title":"Integration","text":"illustrate multi-level integration algorithm, use vignette two 10X PBMCs (Peripheral Blood Mononuclear Cells) 3’ assays: V1 V2. datasets downloaded 10X website. PBMC dataset V1 corresponds sample pbmc6k V2 pbmc8k: V1: pbmc6k V2: pbmc8k  Cells annotated using annotations provided Korsunsky et al., 2019 (Source Data Figure 4 file). overall data downsampled 2K cells (1K per assay) 2K highly variable genes selected scran R package. facilitate reproduction vignette, data distributed Zenodo SingleCellExperiment object, object (class) required functions Coralysis (see Chapter 4 SingleCellExperiment class - OSCA manual). SCE object provided comprises counts (raw count data), logcounts (log-normalized data) cell colData (includes batch cell labels, designated batch cell_type, respectively). Run code import R packages data required reproduce vignette.","code":"# Packages library(\"ggplot2\") library(\"Coralysis\") library(\"SingleCellExperiment\") # Import data from Zenodo data.url <- \"https://zenodo.org/records/14871436/files/pbmc_10Xassays.rds?download=1\" pbmc_10Xassays <- readRDS(file = url(data.url))"},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"dimred-pre-integration","dir":"Articles","previous_headings":"","what":"DimRed: pre-integration","title":"Integration","text":"batch effect assays can inspected projecting data onto t-distributed Stochastic Neighbor Embedding (t-SNE). can achieved running sequentially Coralysis functions RunPCA RunTSNE. Provide seed running one functions ensure reproducibility. function RunPCA runs default PCA method implemented R package irlba (pca.method=\"irlba\"), requires seed ensure PCA result. addition, assay.name argument needs provided, otherwise uses default probabilities obtained integration (running RunParallelDivisiveICP). assay logcounts, corresponding log-normalized data, number principal components use p provided. case, data previously normalized, normalized using methods available Bioconductor (see Chapter 7 Normalization - OSCA manual). categorical variable available colData(pbmc_10Xassays), batch cell_type, can visualized low dimensional embedding stored reducedDimNames(pbmc_10Xassays) Coralysis function PlotDimRed.","code":"# Compute PCA & TSNE set.seed(123) pbmc_10Xassays <- RunPCA(object = pbmc_10Xassays,                           assay.name = \"logcounts\",                           p = 30, dimred.name = \"unintPCA\") set.seed(123) pbmc_10Xassays <- RunTSNE(pbmc_10Xassays,                            dimred.type = \"unintPCA\",                            dimred.name = \"unintTSNE\")  # Plot TSNE highlighting the batch & cell type unint.batch.plot <- PlotDimRed(object = pbmc_10Xassays,                                 color.by = \"batch\",                                 dimred = \"unintTSNE\",                                point.size = 0.01,                                 legend.nrow = 1,                                 seed.color = 1024) unint.cell.plot <- PlotDimRed(object = pbmc_10Xassays,                                color.by = \"cell_type\",                                dimred = \"unintTSNE\",                                point.size = 0.01,                                legend.nrow = 5,                                seed.color = 7) cowplot::plot_grid(unint.batch.plot, unint.cell.plot, ncol = 2, align = \"vh\")"},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"multi-level-integration","dir":"Articles","previous_headings":"","what":"Multi-level integration","title":"Integration","text":"Integrate assays multi-level integration algorithm implemented Coralysis running function RunParallelDivisiveICP. arguments required function object batch.label. object requires SingleCellExperiment object assay logcounts. matrix logcounts sparse, .e., (logcounts(pbmc_10Xassays), \"dgCMatrix\") TRUE, contain non-expressing genes. ensured running PrepareData . batch.label argument requires label column name colData(pbmc_10Xassays) corresponding batch label used integration. absence batch, function, RunParallelDivisiveICP, can run without providing batch.label (.e., batch.label = NULL), case data modeled algorithm identify fine-grained populations required batch correction. higher number threads can provided speed computing time depending number cores available. example, algorithm run 10 times (L = 10), generally, number higher (default L = 50).","code":"# Prepare data for integration:  #remove non-expressing genes & logcounts is from `dgCMatrix` class pbmc_10Xassays <- PrepareData(object = pbmc_10Xassays) ## Data in `logcounts` slot already of `dgCMatrix` class... ## 2000/2000 features remain after filtering features with only zero values. # Perform integration with Coralysis set.seed(1024) pbmc_10Xassays <- RunParallelDivisiveICP(object = pbmc_10Xassays,                                           batch.label = \"batch\",                                           L = 10, threads = 2) ##  ## Building training set... ## Training set successfully built. ##  ## Computing cluster seed. ##  ## Initializing divisive ICP clustering... ##   |                                                                              |                                                                      |   0%  |                                                                              |========                                                              |  11%  |                                                                              |================                                                      |  22%  |                                                                              |=======================                                               |  33%  |                                                                              |===============================                                       |  44%  |                                                                              |=======================================                               |  56%  |                                                                              |===============================================                       |  67%  |                                                                              |======================================================                |  78%  |                                                                              |==============================================================        |  89%  |                                                                              |======================================================================| 100% ##  ## Divisive ICP clustering completed successfully. ##  ## Predicting cell cluster probabilities using ICP models... ## Prediction of cell cluster probabilities completed successfully. ##  ## Multi-level integration completed successfully."},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"dimred-post-integration","dir":"Articles","previous_headings":"","what":"DimRed: post-integration","title":"Integration","text":"integration result can visually inspected running sequentially functions RunPCA RunTSNE. assay.name provided RunPCA must joint.probability (default), primary output integration Coralysis. probability matrices Coralysis (.e., joint.probability) can used obtain integrated embedding running RunPCA(..., assay.name = \"joint.probability\"). integrated PCA can, turn, used downstream clustering non-linear dimensional reduction techniques, RunTSNE. , integrated PCA named intPCA.","code":"# Compute PCA with joint cluster probabilities & TSNE set.seed(123) pbmc_10Xassays <- RunPCA(pbmc_10Xassays,                           assay.name = \"joint.probability\",                           dimred.name = \"intPCA\") ## Divisive ICP: selecting ICP tables multiple of 4 set.seed(123) pbmc_10Xassays <- RunTSNE(pbmc_10Xassays,                            dimred.type = \"intPCA\",                            dimred.name = \"intTSNE\")  # Plot TSNE highlighting the batch & cell type int.batch.plot <- PlotDimRed(object = pbmc_10Xassays,                               color.by = \"batch\",                               dimred = \"intTSNE\",                               point.size = 0.01,                               legend.nrow = 1,                               seed.color = 1024) int.cell.plot <- PlotDimRed(object = pbmc_10Xassays,                              color.by = \"cell_type\",                              dimred = \"intTSNE\",                              point.size = 0.01,                              legend.nrow = 5,                              seed.color = 7) cowplot::plot_grid(int.batch.plot, int.cell.plot,                     ncol = 2, align = \"vh\")"},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"clustering","dir":"Articles","previous_headings":"","what":"Clustering","title":"Integration","text":"Run graph-based clustering scran function clusterCells (see Chapter 5 Clustering - OSCA manual).","code":"# Graph-based clustering on the integrated PCA w/ 'scran' package blusparams <- bluster::SNNGraphParam(k = 15, cluster.fun = \"louvain\") set.seed(123) pbmc_10Xassays$cluster <- scran::clusterCells(pbmc_10Xassays,                                                use.dimred = \"intPCA\",                                                BLUSPARAM = blusparams)  # Plot clustering clt.plot <- PlotDimRed(object = pbmc_10Xassays,                         color.by = \"cluster\",                         dimred = \"intTSNE\",                         point.size = 0.01,                         legend.nrow = 3,                         seed.color = 65) cowplot::plot_grid(int.batch.plot, int.cell.plot,                     clt.plot, ncol = 3, align = \"h\")"},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"cluster-markers","dir":"Articles","previous_headings":"","what":"Cluster markers","title":"Integration","text":"Identify cluster markers running Coralysis function FindAllClusterMarkers. Provide clustering.label, case, label used , .e., cluster. top three positive markers per cluster retrieved plotted using Coralysis function HeatmapFeatures.","code":"# Cluster markers  cluster.markers <- FindAllClusterMarkers(object = pbmc_10Xassays, clustering.label = \"cluster\") ## ----------------------------------- ## testing cluster 1 ## 1128 features left after min.pct filtering ## 1128 features left after min.diff.pct filtering ## 215 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 2 ## 1203 features left after min.pct filtering ## 1203 features left after min.diff.pct filtering ## 287 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 3 ## 1167 features left after min.pct filtering ## 1167 features left after min.diff.pct filtering ## 427 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 4 ## 1171 features left after min.pct filtering ## 1171 features left after min.diff.pct filtering ## 443 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 5 ## 1194 features left after min.pct filtering ## 1194 features left after min.diff.pct filtering ## 283 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 6 ## 1130 features left after min.pct filtering ## 1130 features left after min.diff.pct filtering ## 289 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 7 ## 1199 features left after min.pct filtering ## 1199 features left after min.diff.pct filtering ## 189 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 8 ## 1154 features left after min.pct filtering ## 1154 features left after min.diff.pct filtering ## 392 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 9 ## 1239 features left after min.pct filtering ## 1239 features left after min.diff.pct filtering ## 363 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 10 ## 1473 features left after min.pct filtering ## 1473 features left after min.diff.pct filtering ## 359 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 11 ## 1138 features left after min.pct filtering ## 1138 features left after min.diff.pct filtering ## 280 features left after log2fc.threshold filtering ## ----------------------------------- ## ----------------------------------- ## testing cluster 12 ## 1208 features left after min.pct filtering ## 1208 features left after min.diff.pct filtering ## 344 features left after log2fc.threshold filtering ## ----------------------------------- # Select the top 3 positive markers per cluster  top3.markers <- lapply(X = split(x = cluster.markers, f = cluster.markers$cluster), FUN = function(x) {     head(x[order(x$log2FC, decreasing = TRUE),], n = 3) }) top3.markers <- do.call(rbind, top3.markers) top3.markers <- top3.markers[order(as.numeric(top3.markers$cluster)),]  # Heatmap of the top 3 positive markers per cluster HeatmapFeatures(object = pbmc_10Xassays,                  clustering.label = \"cluster\",                  features = top3.markers$marker,                  seed.color = 65)"},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"dge","dir":"Articles","previous_headings":"","what":"DGE","title":"Integration","text":"Coralysis able separate CD8 effector T cells two clusters: 6 11. differential gene expression (DGE) analysis , clear cluster 11 cytotoxic similar NK cells (expressing GZMH GZMB) cluster 6.","code":"# DGE analysis: cluster 6 vs 11 dge.clt6vs11 <- FindClusterMarkers(pbmc_10Xassays,                                     clustering.label = \"cluster\",                                     clusters.1 = \"6\",                                     clusters.2 = \"11\") ## testing cluster group.1 ## 997 features left after min.pct filtering ## 997 features left after min.diff.pct filtering ## 303 features left after log2fc.threshold filtering head(dge.clt6vs11[order(abs(dge.clt6vs11$log2FC), decreasing = TRUE),]) ##           p.value  adj.p.value    log2FC      pct.1     pct.2  diff.pct marker ## NKG7 3.395687e-65 6.791373e-62 -4.087289 0.11403509 1.0000000 0.8859649   NKG7 ## CCL5 2.349768e-63 4.699536e-60 -3.838459 0.12573099 1.0000000 0.8742690   CCL5 ## GZMH 9.265926e-86 1.853185e-82 -3.170614 0.01461988 1.0000000 0.9853801   GZMH ## CST7 1.986018e-69 3.972037e-66 -2.447930 0.04970760 0.9436620 0.8939544   CST7 ## GZMA 3.278546e-66 6.557091e-63 -2.417989 0.05263158 0.9154930 0.8628614   GZMA ## LTB  2.631790e-33 5.263580e-30  2.325730 0.96491228 0.2253521 0.7395602    LTB top6.degs <- head(dge.clt6vs11[order(abs(dge.clt6vs11$log2FC),                                       decreasing = TRUE),\"marker\"]) exp.plots <- lapply(X = top6.degs, FUN = function(x) {     PlotExpression(object = pbmc_10Xassays, color.by = x,                    scale.values = TRUE, point.size = 0.5, point.stroke = 0.5) }) cowplot::plot_grid(plotlist = exp.plots, align = \"vh\", ncol = 3)"},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"r-session","dir":"Articles","previous_headings":"","what":"R session","title":"Integration","text":"","code":"# R session sessionInfo() ## R version 4.4.2 (2024-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.1 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0 ##  [3] Biobase_2.66.0              GenomicRanges_1.58.0        ##  [5] GenomeInfoDb_1.42.3         IRanges_2.40.1              ##  [7] S4Vectors_0.44.0            BiocGenerics_0.52.0         ##  [9] MatrixGenerics_1.18.1       matrixStats_1.5.0           ## [11] Coralysis_1.0.0             ggplot2_3.5.1               ##  ## loaded via a namespace (and not attached): ##   [1] rlang_1.1.5              magrittr_2.0.3           flexclust_1.4-2          ##   [4] compiler_4.4.2           systemfonts_1.2.1        vctrs_0.6.5              ##   [7] reshape2_1.4.4           stringr_1.5.1            pkgconfig_2.0.3          ##  [10] crayon_1.5.3             fastmap_1.2.0            XVector_0.46.0           ##  [13] labeling_0.4.3           scuttle_1.16.0           rmarkdown_2.29           ##  [16] ggbeeswarm_0.7.2         UCSC.utils_1.2.0         ragg_1.3.3               ##  [19] xfun_0.50                modeltools_0.2-23        bluster_1.16.0           ##  [22] zlibbioc_1.52.0          cachem_1.1.0             beachmat_2.22.0          ##  [25] jsonlite_1.8.9           DelayedArray_0.32.0      BiocParallel_1.40.0      ##  [28] irlba_2.3.5.1            parallel_4.4.2           aricode_1.0.3            ##  [31] cluster_2.1.6            R6_2.6.0                 bslib_0.9.0              ##  [34] stringi_1.8.4            RColorBrewer_1.1-3       limma_3.62.2             ##  [37] jquerylib_0.1.4          Rcpp_1.0.14              iterators_1.0.14         ##  [40] knitr_1.49               snow_0.4-4               Matrix_1.7-1             ##  [43] igraph_2.1.4             tidyselect_1.2.1         abind_1.4-8              ##  [46] yaml_2.3.10              codetools_0.2-20         doRNG_1.8.6.1            ##  [49] lattice_0.22-6           tibble_3.2.1             plyr_1.8.9               ##  [52] withr_3.0.2              ggrastr_1.0.2            Rtsne_0.17               ##  [55] evaluate_1.0.3           desc_1.4.3               pillar_1.10.1            ##  [58] rngtools_1.5.2           foreach_1.5.2            generics_0.1.3           ##  [61] sparseMatrixStats_1.18.0 munsell_0.5.1            scales_1.3.0             ##  [64] class_7.3-22             glue_1.8.0               metapod_1.14.0           ##  [67] pheatmap_1.0.12          LiblineaR_2.10-24        tools_4.4.2              ##  [70] BiocNeighbors_2.0.1      ScaledMatrix_1.14.0      SparseM_1.84-2           ##  [73] RSpectra_0.16-2          locfit_1.5-9.11          RANN_2.6.2               ##  [76] fs_1.6.5                 scran_1.34.0             Cairo_1.6-2              ##  [79] cowplot_1.1.3            grid_4.4.2               edgeR_4.4.2              ##  [82] colorspace_2.1-1         GenomeInfoDbData_1.2.13  beeswarm_0.4.0           ##  [85] BiocSingular_1.22.0      vipor_0.4.7              cli_3.6.4                ##  [88] rsvd_1.0.5               textshaping_1.0.0        viridisLite_0.4.2        ##  [91] S4Arrays_1.6.0           dplyr_1.1.4              doSNOW_1.0.20            ##  [94] gtable_0.3.6             sass_0.4.9               digest_0.6.37            ##  [97] SparseArray_1.6.1        dqrng_0.4.1              farver_2.1.2             ## [100] htmltools_0.5.8.1        pkgdown_2.1.1            lifecycle_1.0.4          ## [103] httr_1.4.7               statmod_1.5.0"},{"path":"https://elolab.github.io/Coralysis/articles/Integration.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Integration","text":"Amezquita R, Lun , Becht E, Carey V, Carpp L, Geistlinger L, Marini F, Rue-Albrecht K, Risso D, Soneson C, Waldron L, Pages H, Smith M, Huber W, Morgan M, Gottardo R, Hicks S (2020). “Orchestrating single-cell analysis Bioconductor.” Nature Methods, 17, 137-145. https://www.nature.com/articles/s41592-019-0654-x. Korsunsky , Millard N, Fan J, Slowikowski K, Zhang F, Wei K, Baglaenko Y, Brenner M, Loh P, Raychaudhuri S. (2019). “Fast, sensitive accurate integration single-cell data Harmony.” Nature Methods. 16(12):1289-1296. 10.1038/s41592-019-0619-0 Lun ATL, McCarthy DJ, Marioni JC (2016). “step--step workflow low-level analysis single-cell RNA-seq data Bioconductor.” F1000Res., 5, 2122. doi:10.12688/f1000research.9501.2. Sousa , Smolander J, Junttila S, Elo L (2025). “Coralysis enables sensitive identification imbalanced cell types states single-cell data via multi-level integration.” bioRxiv. doi:10.1101/2025.02.07.637023 Wickham H (2016). “ggplot2: Elegant Graphics Data Analysis.” Springer-Verlag New York.","code":""},{"path":"https://elolab.github.io/Coralysis/articles/RefMap.html","id":"dataset","dir":"Articles","previous_headings":"","what":"Dataset","title":"Reference-mapping","text":"illustrate Coralysis reference-mapping method, use vignette two 10X PBMCs (Peripheral Blood Mononuclear Cells) 3’ assays: V1 V2. assay V2 reference V1 query, .e., dataset mapped reference. datasets downloaded 10X website. PBMC dataset V1 corresponds sample pbmc6k V2 pbmc8k: V1: pbmc6k V2: pbmc8k  Cells annotated using annotations provided Korsunsky et al., 2019 (Source Data Figure 4 file). overall data downsampled 2K cells (1K per assay) 2K highly variable genes selected scran R package. facilitate reproduction vignette, data distributed Zenodo SingleCellExperiment object, object (class) required functions Coralysis (see Chapter 4 SingleCellExperiment class - OSCA manual). SCE object provided comprises counts (raw count data), logcounts (log-normalized data) cell colData (includes batch cell labels, designated batch cell_type, respectively). Run code import R packages data required reproduce vignette.","code":"# Packages library(\"ggplot2\") library(\"Coralysis\") library(\"SingleCellExperiment\") # Import data from Zenodo data.url <- \"https://zenodo.org/records/14871436/files/pbmc_10Xassays.rds?download=1\" pbmc_10Xassays <- readRDS(file = url(data.url))  # Split the SCE object by assay  ref <- pbmc_10Xassays[,pbmc_10Xassays$batch==\"V2\"] # let V2 assay batch be the reference data set query <- pbmc_10Xassays[,pbmc_10Xassays$batch==\"V1\"] # let V1 be the query (unknown annotations)"},{"path":"https://elolab.github.io/Coralysis/articles/RefMap.html","id":"train-reference","dir":"Articles","previous_headings":"","what":"Train reference","title":"Reference-mapping","text":"first step performing reference mapping Coralysis training dataset representative biological system study. example, ref query correspond SingleCellExperiment objects reference query PBMC samples, V2 V1 3’ assays, respectively. reference ref trained RunParallelDivisiveICP function without providing batch.label. case reference requires integration, batch.label provided. higher number threads can provided speed computing time depending number cores available. example, algorithm run 10 times (L = 10), generally, number higher (default L = 50). Next, run function RunPCA obtain main result required cell type prediction later . addition cell type prediction, query dataset(s) can projected onto UMAP. allow , argument return.model set TRUE functions RunPCA RunUMAP. UMAP plot reference sample cell type annotations. example, using annotations provided object. Ideally, sample annotated training performing clustering manual cluster annotation. resulting manual cell type annotations used prediction. simplicity, use annotations provided object.","code":"# Train the reference  set.seed(123) ref <- RunParallelDivisiveICP(object = ref, L = 10, threads = 2) # runs without 'batch.label' ## WARNING: Setting 'divisive.method' to 'cluster' as 'batch.label=NULL'.  ## If 'batch.label=NULL', 'divisive.method' can be one of: 'cluster', 'random'. ##  ## Building training set... ## Training set successfully built. ##  ## Computing cluster seed. ##  ## Initializing divisive ICP clustering... ##   |                                                                              |                                                                      |   0%  |                                                                              |========                                                              |  11%  |                                                                              |================                                                      |  22%  |                                                                              |=======================                                               |  33%  |                                                                              |===============================                                       |  44%  |                                                                              |=======================================                               |  56%  |                                                                              |===============================================                       |  67%  |                                                                              |======================================================                |  78%  |                                                                              |==============================================================        |  89%  |                                                                              |======================================================================| 100% ##  ## Divisive ICP clustering completed successfully. ##  ## Predicting cell cluster probabilities using ICP models... ## Prediction of cell cluster probabilities completed successfully. ##  ## Multi-level integration completed successfully. # Compute reference PCA ref <- RunPCA(ref, return.model = TRUE, pca.method = \"stats\") ## Divisive ICP: selecting ICP tables multiple of 4 # Compute reference UMAP set.seed(123) ref <- RunUMAP(ref, return.model = TRUE) # Vizualize reference ref.celltype.plot <- PlotDimRed(object = ref,                                  color.by = \"cell_type\",                                  dimred = \"UMAP\",                                  point.size = 0.01,                                  legend.nrow = 6,                                  seed.color = 7) +      ggtitle(\"reference (ground-truth)\") ref.celltype.plot"},{"path":"https://elolab.github.io/Coralysis/articles/RefMap.html","id":"map-query","dir":"Articles","previous_headings":"","what":"Map query","title":"Reference-mapping","text":"Perform reference-mapping Coralysis running function ReferenceMapping. requires provide trained reference (ref) cell type annotations intended prediction (ref.label = \"cell_type\") query dataset (query). label reference aimed used prediction needs available colData(ref). case, providing cell type labels column cell_type available reference ref. Since want project query onto reference UMAP, set project.umap TRUE. argument dimred.name.prefix just sets name given prefix low dimensional embeddings stored reducedDimNames(map). SingleCellExperiment object map contain information query, predictions embeddings mapped onto reference. predictions consist coral_labels coral_probability stored colData(map). coral_labels correspond cell type predictions obtained reference. coral_probability represents proportion K neighbors winning class (k.nn equal 10 default); higher value, better.","code":"## Reference-mapping set.seed(1024) map <- ReferenceMapping(ref = ref, query = query, ref.label = \"cell_type\",                          project.umap = TRUE, dimred.name.prefix = \"ref\")"},{"path":"https://elolab.github.io/Coralysis/articles/RefMap.html","id":"prediction-accuracy","dir":"Articles","previous_headings":"","what":"Prediction accuracy","title":"Reference-mapping","text":"accuracy Coralysis reference-mapping method presented together confusion matrix predicted (rows) versus ground-truth cell type labels (columns).","code":""},{"path":"https://elolab.github.io/Coralysis/articles/RefMap.html","id":"confusion-matrix","dir":"Articles","previous_headings":"Prediction accuracy","what":"Confusion matrix","title":"Reference-mapping","text":"accuracy Coralysis reference-mapping method 84.2%.","code":"# Confusion matrix preds_x_truth <- table(map$coral_labels, map$cell_type) stopifnot(all(row.names(preds_x_truth)==colnames(preds_x_truth)))  # Accuracy acc <- sum(diag(preds_x_truth)) / sum(preds_x_truth) #print(paste0(\"Prediction accuracy: \", acc*100, \"%\"))  # Print confusion matrix preds_x_truth ##                  ##                  aDC B mem B naive CD4 mem CD4 naive CD8 eff CD8 T HSC ##   aDC             14     0       0       0         0       0     0   0 ##   B mem            0    40      15       0         0       0     0   3 ##   B naive          0     4      69       0         0       0     0   0 ##   CD4 mem          0     0       0     108        39       3     6   0 ##   CD4 naive        0     0       0      14       153       0    12   2 ##   CD8 eff          0     1       0       2         0      93     2   0 ##   CD8 T            0     0       1       3         4      11    62   0 ##   HSC              0     0       0       0         0       0     0   0 ##   Megakaryocyte    0     0       0       0         0       0     0   0 ##   Monocyte         1     0       0       0         0       0     0   0 ##   CD16+ monocyte   0     0       0       0         0       0     0   0 ##   NK               0     0       0       0         0       1     0   0 ##   pDC              0     0       0       0         0       0     0   0 ##   Treg             0     0       0       1         0       0     0   0 ##                  ##                  Megakaryocyte Monocyte CD16+ monocyte  NK pDC Treg ##   aDC                        0        0              0   0   0    0 ##   B mem                      0        0              0   0   0    0 ##   B naive                    0        0              0   0   1    0 ##   CD4 mem                    0        0              0   0   0    8 ##   CD4 naive                  0        0              0   0   0    7 ##   CD8 eff                    1        0              0   1   0    0 ##   CD8 T                      1        0              0   0   0    0 ##   HSC                        0        0              0   0   0    0 ##   Megakaryocyte              0        0              0   0   0    0 ##   Monocyte                   3      173              4   1   0    0 ##   CD16+ monocyte             1        5             72   0   0    0 ##   NK                         0        0              0  55   0    0 ##   pDC                        0        0              0   0   3    0 ##   Treg                       0        0              0   0   0    0"},{"path":"https://elolab.github.io/Coralysis/articles/RefMap.html","id":"dimred","dir":"Articles","previous_headings":"Prediction accuracy","what":"DimRed","title":"Reference-mapping","text":"Visualize query cells projected onto reference UMAP well predictions match query ground-truth. coral_probability prediction confidence score. Predictions low scores (<0.5) carefully inspected.","code":"# Plot query and reference UMAP side-by-side  #with ground-truth & predicted cell labels use.color <- c(\"aDC\" = \"#E6F5C9\",                 \"B mem\" = \"#CCEBC5\",                 \"B naive\" = \"#FB8072\",                 \"CD4 mem\" = \"#A6761D\",                 \"CD4 naive\" = \"#666666\",                 \"CD8 eff\" = \"#80B1D3\",                \"CD8 T\" = \"#CBD5E8\",                 \"HSC\" = \"#E31A1C\",                 \"Megakaryocyte\" = \"#377EB8\",                 \"Monocyte\" = \"#FCCDE5\",                 \"CD16+ monocyte\" = \"#A6D854\",                 \"NK\" = \"#6A3D9A\",                \"pDC\" = \"#E7298A\",                 \"Treg\" = \"#FFFF33\") query.ground_truth.plot <- PlotDimRed(object = map,                                        color.by = \"cell_type\",                                        dimred = \"refUMAP\",                                        point.size = 0.01,                                        legend.nrow = 6,                                        seed.color = 7) +      ggtitle(\"query (ground-truth)\") query.predicted.plot <-PlotDimRed(object = map,                                    color.by = \"coral_labels\",                                    dimred = \"refUMAP\", point.size = 0.01,                                    legend.nrow = 6,                                    use.color = use.color) +      ggtitle(\"query (predicted)\") query.confidence.plot <- PlotExpression(object = map,                                          color.by = \"coral_probability\",                                          dimred = \"refUMAP\",                                          point.size = 0.01,                                          color.scale = \"viridis\") +      ggtitle(\"query (confidence)\") cowplot::plot_grid(ref.celltype.plot, query.ground_truth.plot,                     query.predicted.plot, query.confidence.plot,                     ncol = 2, align = \"vh\")"},{"path":"https://elolab.github.io/Coralysis/articles/RefMap.html","id":"r-session","dir":"Articles","previous_headings":"","what":"R session","title":"Reference-mapping","text":"","code":"# R session sessionInfo() ## R version 4.4.2 (2024-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.1 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0 ##  [3] Biobase_2.66.0              GenomicRanges_1.58.0        ##  [5] GenomeInfoDb_1.42.3         IRanges_2.40.1              ##  [7] S4Vectors_0.44.0            BiocGenerics_0.52.0         ##  [9] MatrixGenerics_1.18.1       matrixStats_1.5.0           ## [11] Coralysis_1.0.0             ggplot2_3.5.1               ##  ## loaded via a namespace (and not attached): ##   [1] rlang_1.1.5              magrittr_2.0.3           flexclust_1.4-2          ##   [4] compiler_4.4.2           png_0.1-8                systemfonts_1.2.1        ##   [7] vctrs_0.6.5              reshape2_1.4.4           stringr_1.5.1            ##  [10] pkgconfig_2.0.3          crayon_1.5.3             fastmap_1.2.0            ##  [13] XVector_0.46.0           labeling_0.4.3           scuttle_1.16.0           ##  [16] rmarkdown_2.29           ggbeeswarm_0.7.2         UCSC.utils_1.2.0         ##  [19] ragg_1.3.3               xfun_0.50                modeltools_0.2-23        ##  [22] bluster_1.16.0           zlibbioc_1.52.0          cachem_1.1.0             ##  [25] beachmat_2.22.0          jsonlite_1.8.9           DelayedArray_0.32.0      ##  [28] BiocParallel_1.40.0      irlba_2.3.5.1            parallel_4.4.2           ##  [31] aricode_1.0.3            cluster_2.1.6            R6_2.6.0                 ##  [34] bslib_0.9.0              stringi_1.8.4            RColorBrewer_1.1-3       ##  [37] reticulate_1.40.0        limma_3.62.2             jquerylib_0.1.4          ##  [40] Rcpp_1.0.14              iterators_1.0.14         knitr_1.49               ##  [43] snow_0.4-4               Matrix_1.7-1             igraph_2.1.4             ##  [46] tidyselect_1.2.1         abind_1.4-8              yaml_2.3.10              ##  [49] codetools_0.2-20         doRNG_1.8.6.1            lattice_0.22-6           ##  [52] tibble_3.2.1             plyr_1.8.9               withr_3.0.2              ##  [55] askpass_1.2.1            ggrastr_1.0.2            evaluate_1.0.3           ##  [58] desc_1.4.3               pillar_1.10.1            rngtools_1.5.2           ##  [61] foreach_1.5.2            generics_0.1.3           sparseMatrixStats_1.18.0 ##  [64] munsell_0.5.1            scales_1.3.0             class_7.3-22             ##  [67] glue_1.8.0               metapod_1.14.0           pheatmap_1.0.12          ##  [70] LiblineaR_2.10-24        tools_4.4.2              BiocNeighbors_2.0.1      ##  [73] ScaledMatrix_1.14.0      SparseM_1.84-2           RSpectra_0.16-2          ##  [76] locfit_1.5-9.11          RANN_2.6.2               fs_1.6.5                 ##  [79] scran_1.34.0             Cairo_1.6-2              cowplot_1.1.3            ##  [82] grid_4.4.2               umap_0.2.10.0            edgeR_4.4.2              ##  [85] colorspace_2.1-1         GenomeInfoDbData_1.2.13  beeswarm_0.4.0           ##  [88] BiocSingular_1.22.0      vipor_0.4.7              cli_3.6.4                ##  [91] rsvd_1.0.5               textshaping_1.0.0        viridisLite_0.4.2        ##  [94] S4Arrays_1.6.0           dplyr_1.1.4              doSNOW_1.0.20            ##  [97] gtable_0.3.6             sass_0.4.9               digest_0.6.37            ## [100] SparseArray_1.6.1        dqrng_0.4.1              farver_2.1.2             ## [103] htmltools_0.5.8.1        pkgdown_2.1.1            lifecycle_1.0.4          ## [106] httr_1.4.7               statmod_1.5.0            openssl_2.3.2"},{"path":"https://elolab.github.io/Coralysis/articles/RefMap.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Reference-mapping","text":"Amezquita R, Lun , Becht E, Carey V, Carpp L, Geistlinger L, Marini F, Rue-Albrecht K, Risso D, Soneson C, Waldron L, Pages H, Smith M, Huber W, Morgan M, Gottardo R, Hicks S (2020). “Orchestrating single-cell analysis Bioconductor.” Nature Methods, 17, 137-145. https://www.nature.com/articles/s41592-019-0654-x. Korsunsky , Millard N, Fan J, Slowikowski K, Zhang F, Wei K, Baglaenko Y, Brenner M, Loh P, Raychaudhuri S. (2019). “Fast, sensitive accurate integration single-cell data Harmony.” Nature Methods. 16(12):1289-1296. 10.1038/s41592-019-0619-0 Sousa , Smolander J, Junttila S, Elo L (2025). “Coralysis enables sensitive identification imbalanced cell types states single-cell data via multi-level integration.” bioRxiv. doi:10.1101/2025.02.07.637023 Wickham H (2016). “ggplot2: Elegant Graphics Data Analysis.” Springer-Verlag New York.","code":""},{"path":"https://elolab.github.io/Coralysis/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"António Sousa. Maintainer, author. Johannes Smolander. Contributor, author. Sini Junttila. Author. Laura L Elo. Author.","code":""},{"path":"https://elolab.github.io/Coralysis/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sousa , Smolander J, Junttila S, Elo L (2025). “Coralysis enables sensitive identification imbalanced cell types states single-cell data via multi-level integration.” bioRxiv. doi:10.1101/2025.02.07.637023, R package version 1.0.0.","code":"@Article{,   author = {António G.G. Sousa and Johannes Smolander and Sini Junttila and Laura L. Elo},   title = {Coralysis enables sensitive identification of imbalanced cell types and states in single-cell data via multi-level integration},   year = {2025},   doi = {10.1101/2025.02.07.637023},   publisher = {Cold Spring Harbor Laboratory},   journal = {bioRxiv},   note = {R package version 1.0.0}, }"},{"path":[]},{"path":"https://elolab.github.io/Coralysis/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Coralysis sensitive identification of imbalanced cell types and states in single-cell data via multi-level integration","text":"Coralysis R package featuring multi-level integration algorithm sensitive integration, reference-mapping, cell state identification single-cell data, described paper “Coralysis enables sensitive identification imbalanced cell types states single-cell data via multi-level integration”.   Coralysis integration flowchart. () input heterogeneous scRNA-seq datasets overclustered batch wise training set modelled Iterative Clustering Projection (ICP) algorithm order predict cell cluster probabilities obtain integrated embedding. Adaptations original ICP algorithm (Smolander et al., 2021): (B) batch wise cluster assignment start, dependent cell distribution across Principal Component 1 (median cutoff); (C) training cells selected batch k nearest neighbours cell highest probability every batch per cluster; , (D) upon ICP clustering convergence, cluster divided two next clustering round, dependent batch wise cluster probability distribution (median cutoff). (E) Multi-level integration achieved multiple divisive clustering rounds, blending batch effect highlighting biological signal incrementally. Shapes represent cell types colours batches.","code":""},{"path":"https://elolab.github.io/Coralysis/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Coralysis sensitive identification of imbalanced cell types and states in single-cell data via multi-level integration","text":"latest version Coralysis can downloaded GitHub using devtools R package.","code":"devtools::install_github(\"elolab/Coralysis\")"},{"path":"https://elolab.github.io/Coralysis/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Coralysis sensitive identification of imbalanced cell types and states in single-cell data via multi-level integration","text":"Sousa , Smolander J, Junttila S, Elo L (2025). Coralysis enables sensitive identification imbalanced cell types states single-cell data via multi-level integration. bioRxiv. doi:10.1101/2025.02.07.637023","code":""},{"path":"https://elolab.github.io/Coralysis/index.html","id":"contact-information","dir":"","previous_headings":"","what":"Contact information","title":"Coralysis sensitive identification of imbalanced cell types and states in single-cell data via multi-level integration","text":"questions related Coralysis, please contact us .","code":""},{"path":"https://elolab.github.io/Coralysis/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Coralysis sensitive identification of imbalanced cell types and states in single-cell data via multi-level integration","text":"Johannes Smolander, Sini Junttila, Mikko S Venäläinen, Laura L Elo. “ILoReg: tool high-resolution cell population identification single-cell RNA-seq data”. Bioinformatics, Volume 37, Issue 8, 15 April 2021, Pages 1107–1114, https://doi.org/10.1093/bioinformatics/btaa919.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/AggregateClusterExpression.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregates cell feature expression by clusters — AggregateClusterExpression","title":"Aggregates cell feature expression by clusters — AggregateClusterExpression","text":"function aggregates cell feature expression clusters provided.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/AggregateClusterExpression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregates cell feature expression by clusters — AggregateClusterExpression","text":"","code":"AggregateClusterExpression(mtx, cluster, select.features = NULL, fun = \"mean\")"},{"path":"https://elolab.github.io/Coralysis/reference/AggregateClusterExpression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregates cell feature expression by clusters — AggregateClusterExpression","text":"mtx Matrix features vs cells (rows vs cols) feature expression aggregate. cluster Cluster identities vector corresponding cells mtx. select.features features selected. default NULL, features used. fun Character specifying feature expression aggregated mean sum. default \"mean\".","code":""},{"path":"https://elolab.github.io/Coralysis/reference/AggregateClusterExpression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregates cell feature expression by clusters — AggregateClusterExpression","text":"Matrix feature expressed aggregated clusters.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/AggregateDataByBatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregates feature expression by cell clusters, per batch if provided. — AggregateDataByBatch","title":"Aggregates feature expression by cell clusters, per batch if provided. — AggregateDataByBatch","text":"function aggregates feature expression cell clusters, per batch provided.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/AggregateDataByBatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregates feature expression by cell clusters, per batch if provided. — AggregateDataByBatch","text":"","code":"AggregateDataByBatch.SingleCellExperiment(object, batch.label, nhvg, p, ...)  # S4 method for class 'SingleCellExperiment' AggregateDataByBatch(object, batch.label, nhvg = 2000L, p = 30L, ...)"},{"path":"https://elolab.github.io/Coralysis/reference/AggregateDataByBatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregates feature expression by cell clusters, per batch if provided. — AggregateDataByBatch","text":"object object SingleCellExperiment class. batch.label Cluster identities vector corresponding cells mtx. nhvg Integer number highly variable features select. default 2000. p Integer. default 30. ... Parameters passed ClusterCells() function.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/AggregateDataByBatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregates feature expression by cell clusters, per batch if provided. — AggregateDataByBatch","text":"SingleCellExperiment object feature expression aggregated clusters.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/AggregateDataByBatch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregates feature expression by cell clusters, per batch if provided. — AggregateDataByBatch","text":"","code":"if (FALSE) { # \\dontrun{ # Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Import data from Zenodo data.url <- \"https://zenodo.org/records/14845751/files/pbmc_10Xassays.rds?download=1\" sce <- readRDS(file = url(data.url))  # Run with a batch set.seed(1204) sce <- AggregateDataByBatch(object = sce, batch.label = \"batch\") logcounts(sce)[1:10,1:10] head(metadata(sce)$clusters)  # Run without a batch set.seed(1204) sce <- AggregateDataByBatch(object = sce, batch.label = NULL) logcounts(sce)[1:10,1:10] head(metadata(sce)$clusters) } # }"},{"path":"https://elolab.github.io/Coralysis/reference/BinCellClusterProbability.html","id":null,"dir":"Reference","previous_headings":"","what":"Bin cell cluster probability — BinCellClusterProbability","title":"Bin cell cluster probability — BinCellClusterProbability","text":"Bin cell cluster probability given cell label.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/BinCellClusterProbability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bin cell cluster probability — BinCellClusterProbability","text":"","code":"BinCellClusterProbability.SingleCellExperiment(   object,   label,   icp.run,   icp.round,   funs,   bins,   aggregate.bins.by,   use.assay )  # S4 method for class 'SingleCellExperiment' BinCellClusterProbability(   object,   label,   icp.run = NULL,   icp.round = NULL,   funs = \"mean\",   bins = 20,   aggregate.bins.by = \"mean\",   use.assay = \"logcounts\" )"},{"path":"https://elolab.github.io/Coralysis/reference/BinCellClusterProbability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bin cell cluster probability — BinCellClusterProbability","text":"object object SingleCellExperiment class ICP cell cluster probability tables saved metadata(object)$coralysis$joint.probability. running one RunParallelICP RunParallelDivisiveICP. label Label interest available colData(object) group bins cell cluster probability. icp.run ICP run(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved. Specify numeric vector retrieve specific set tables. icp.round ICP round(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved. relevant probabilities obtained function RunParallelDivisiveICP, .e., divisive ICP performed. Otherwise ignored internally assumed icp.round = 1, .e., one round. funs One function summarise ICP cell cluster probability. One \"mean\" \"median\". default \"mean\". bins Number bins bin cell cluster probability cell label given. default 20. aggregate.bins.One function aggregate One \"mean\" \"median\". default \"mean\". use.assay Name assay used obtain average expression features across cell label probability bins.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/BinCellClusterProbability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bin cell cluster probability — BinCellClusterProbability","text":"SingleCellExperiment class object feature average expression cell label probability bins.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/BinCellClusterProbability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bin cell cluster probability — BinCellClusterProbability","text":"","code":"if (FALSE) { # \\dontrun{ # Packages suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Import data from Zenodo data.url <- \"https://zenodo.org/records/14845751/files/pbmc_10Xassays.rds?download=1\" sce <- readRDS(file = url(data.url))  # Prepare data sce <- PrepareData(object = sce)  # Multi-level integration - 'L = 4' just for highlighting purposes set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"batch\", L = 4,                                threads = 2)  # Cell states SCE object for a given cell type annotation or clustering cellstate.sce <- BinCellClusterProbability(object = sce, label = \"cell_type\",                                             icp.round = 4, bins = 20)  cellstate.sce } # }"},{"path":"https://elolab.github.io/Coralysis/reference/CellBinsFeatureCorrelation.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell bins feature correlation — CellBinsFeatureCorrelation","title":"Cell bins feature correlation — CellBinsFeatureCorrelation","text":"Correlation cell bins given labels features.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/CellBinsFeatureCorrelation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell bins feature correlation — CellBinsFeatureCorrelation","text":"","code":"CellBinsFeatureCorrelation.SingleCellExperiment(object, labels, method)  # S4 method for class 'SingleCellExperiment' CellBinsFeatureCorrelation(object, labels = NULL, method = \"pearson\")"},{"path":"https://elolab.github.io/Coralysis/reference/CellBinsFeatureCorrelation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell bins feature correlation — CellBinsFeatureCorrelation","text":"object object SingleCellExperiment class obtained function BinCellClusterProbability(). labels Character label(s) label provided function BinCellClusterProbability(). default NULL, .e., labels used. method Character specifying correlation method use. One \"pearson\", \"kendall\" \"spearman\". default \"pearson\" used.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/CellBinsFeatureCorrelation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell bins feature correlation — CellBinsFeatureCorrelation","text":"data frame correlation coefficient feature (rows) across labels (columns).","code":""},{"path":"https://elolab.github.io/Coralysis/reference/CellBinsFeatureCorrelation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell bins feature correlation — CellBinsFeatureCorrelation","text":"","code":"if (FALSE) { # \\dontrun{ # Packages suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Import data from Zenodo data.url <- \"https://zenodo.org/records/14845751/files/pbmc_10Xassays.rds?download=1\" sce <- readRDS(file = url(data.url))  # Prepare data sce <- PrepareData(object = sce)  # Multi-level integration - 'L = 4' just for highlighting purposes set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"batch\", L = 4,                                threads = 2)  # Cell states SCE object for a given cell type annotation or clustering cellstate.sce <- BinCellClusterProbability(object = sce, label = \"cell_type\",                                             icp.round = 4, bins = 20)  cellstate.sce  # Pearson correlated features with \"Monocyte\" cor.features.mono <- CellBinsFeatureCorrelation(object = cellstate.sce,                                                  labels = \"Monocyte\") } # }"},{"path":"https://elolab.github.io/Coralysis/reference/CellClusterProbabilityDistribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Cell cluster probability distribution — CellClusterProbabilityDistribution","title":"Cell cluster probability distribution — CellClusterProbabilityDistribution","text":"Plot cell cluster probability distribution per label group.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/CellClusterProbabilityDistribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cell cluster probability distribution — CellClusterProbabilityDistribution","text":"","code":"CellClusterProbabilityDistribution.SingleCellExperiment(   object,   label,   group,   probability )  # S4 method for class 'SingleCellExperiment' CellClusterProbabilityDistribution(   object,   label,   group,   probability = \"scaled_mean_probs\" )"},{"path":"https://elolab.github.io/Coralysis/reference/CellClusterProbabilityDistribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cell cluster probability distribution — CellClusterProbabilityDistribution","text":"object object SingleCellExperiment class aggregated cell cluster probability available colData(object), can obtained running SummariseCellClusterProbability(). label Character specifying colData variable use cell type/cluster label. group Character specifying colData variable use categorical group variable. probability Character specifying aggregated cell cluster probability variable available colData, used plot distribution. One \"mean_probs\", \"scaled_mean_probs\", \"median_probs\", \"scaled_median_probs\". availability variables colData depends parameters given function SummariseCellClusterProbability() beforehand. default assumes \"scaled_mean_probs\" available colData, true SummariseCellClusterProbability() function run funs = \"mean\" scale.funs = TRUE.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/CellClusterProbabilityDistribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cell cluster probability distribution — CellClusterProbabilityDistribution","text":"plot class ggplot.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/CellClusterProbabilityDistribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cell cluster probability distribution — CellClusterProbabilityDistribution","text":"","code":"if (FALSE) { # \\dontrun{ # Packages suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Import data from Zenodo data.url <- \"https://zenodo.org/records/14845751/files/pbmc_10Xassays.rds?download=1\" sce <- readRDS(file = url(data.url))  # Prepare data sce <- PrepareData(object = sce)  # Multi-level integration - 'L = 4' just for highlighting purposes set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"batch\", L = 4,                                threads = 2)  # Summarise cell cluster probability sce <- SummariseCellClusterProbability(object = sce, icp.round = 4) # saved in 'colData'  # Search for differences in probabilities across group(s)  # give an interesting variable to the \"group\" parameter prob.dist <- CellClusterProbabilityDistribution(object = sce, label = \"cell_type\",                                                  group = \"batch\",                                                  probability = \"scaled_mean_probs\") prob.dist # print plot } # }"},{"path":"https://elolab.github.io/Coralysis/reference/ClusterCells.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster cells — ClusterCells","title":"Cluster cells — ClusterCells","text":"function clusters cells K-means++ algorithm","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ClusterCells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster cells — ClusterCells","text":"","code":"ClusterCells(object, nclusters = 500, use.emb = TRUE, emb.name = \"PCA\")"},{"path":"https://elolab.github.io/Coralysis/reference/ClusterCells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster cells — ClusterCells","text":"object object SingleCellExperiment class. nclusters Cluster cells n clusters. Ignored number cells object lower equal nclusters. use.emb embedding used cluster log-transformed data. default TRUE. emb.name embedding use. default \"PCA\".","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ClusterCells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster cells — ClusterCells","text":"SingleCellExperiment object clusters.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/DownOverSampleEvenlyBatches.html","id":null,"dir":"Reference","previous_headings":"","what":"Down- and oversample data evenly batches — DownOverSampleEvenlyBatches","title":"Down- and oversample data evenly batches — DownOverSampleEvenlyBatches","text":"function - -samples cluster cells evenly batch.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/DownOverSampleEvenlyBatches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Down- and oversample data evenly batches — DownOverSampleEvenlyBatches","text":"","code":"DownOverSampleEvenlyBatches(x, batch, n = 50)"},{"path":"https://elolab.github.io/Coralysis/reference/DownOverSampleEvenlyBatches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Down- and oversample data evenly batches — DownOverSampleEvenlyBatches","text":"x character numeric vector data -oversample. batch character vector batch labels corresponding x. n many cells include per cluster.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/DownOverSampleEvenlyBatches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Down- and oversample data evenly batches — DownOverSampleEvenlyBatches","text":"list containing output LiblineaR prediction","code":""},{"path":"https://elolab.github.io/Coralysis/reference/DownOverSampling.html","id":null,"dir":"Reference","previous_headings":"","what":"Down- and oversample data — DownOverSampling","title":"Down- and oversample data — DownOverSampling","text":"function implements script - oversamples data include n cells.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/DownOverSampling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Down- and oversample data — DownOverSampling","text":"","code":"DownOverSampling(x, n = 50)"},{"path":"https://elolab.github.io/Coralysis/reference/DownOverSampling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Down- and oversample data — DownOverSampling","text":"x character numeric vector data -oversample. n many cells include per cluster.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/DownOverSampling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Down- and oversample data — DownOverSampling","text":"list containing output LiblineaR prediction","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindAllClusterMarkers.html","id":null,"dir":"Reference","previous_headings":"","what":"Identification of feature markers for all clusters — FindAllClusterMarkers","title":"Identification of feature markers for all clusters — FindAllClusterMarkers","text":"FindAllClusterMarkers enables identifying feature markers clusters . done differential expresission analysis cells one cluster compared cells rest clusters. Feature cell filters can applied accelerate analysis, might lead missing weak signals.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindAllClusterMarkers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identification of feature markers for all clusters — FindAllClusterMarkers","text":"","code":"FindAllClusterMarkers.SingleCellExperiment(   object,   clustering.label,   test,   log2fc.threshold,   min.pct,   min.diff.pct,   min.cells.group,   max.cells.per.cluster,   return.thresh,   only.pos )  # S4 method for class 'SingleCellExperiment' FindAllClusterMarkers(   object,   clustering.label,   test = \"wilcox\",   log2fc.threshold = 0.25,   min.pct = 0.1,   min.diff.pct = NULL,   min.cells.group = 3,   max.cells.per.cluster = NULL,   return.thresh = 0.01,   only.pos = FALSE )"},{"path":"https://elolab.github.io/Coralysis/reference/FindAllClusterMarkers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identification of feature markers for all clusters — FindAllClusterMarkers","text":"object SingleCellExperiment object. clustering.label variable name (class character) available cell metadata colData(object) clustering labels (character factor) use. test test use. \"wilcox\" (Wilcoxon rank-sum test, AKA Mann-Whitney U test) supported moment. log2fc.threshold Filters features log2 fold-change averaged feature expression values threshold. Default 0.25. min.pct Filters features dropout rate (fraction cells expressing feature) threshold comparison groups. Default 0.1. min.diff.pct Filters features minimum difference dropout rates (fraction cells expressing feature) two comparison groups. Default NULL. min.cells.group minimum number cells two comparison groups perform DE analysis. number cells threshold, DE analysis cluster skipped. Default 3. max.cells.per.cluster maximum number cells per cluster downsampling performed speed DE analysis. Default NULL, .e., downsampling. return.thresh .pos=TRUE, return features adjusted p-value (adjusted Bonferroni method) equal threshold. Default 0.01. .pos Whether return features adjusted p-value (adjusted Bonferroni method) equal threshold. Default FALSE.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindAllClusterMarkers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identification of feature markers for all clusters — FindAllClusterMarkers","text":"data frame results positive results found, else NULL.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindAllClusterMarkers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identification of feature markers for all clusters — FindAllClusterMarkers","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Markers dge <- FindAllClusterMarkers(sce, clustering.label = \"Species\") #> ----------------------------------- #> testing cluster setosa #> 4 features left after min.pct filtering #> 4 features left after min.diff.pct filtering #> 4 features left after log2fc.threshold filtering #> ----------------------------------- #> ----------------------------------- #> testing cluster versicolor #> 4 features left after min.pct filtering #> 4 features left after min.diff.pct filtering #> 2 features left after log2fc.threshold filtering #> ----------------------------------- #> ----------------------------------- #> testing cluster virginica #> 4 features left after min.pct filtering #> 4 features left after min.diff.pct filtering #> 3 features left after log2fc.threshold filtering #> ----------------------------------- dge #>                     p.value  adj.p.value log2FC pct.1 pct.2 diff.pct    cluster #> Sepal.Length   5.804234e-20 2.321694e-19 -1.256     1     1        0     setosa #> Sepal.Width    3.027113e-14 1.210845e-13  0.556     1     1        0     setosa #> Petal.Length   1.952841e-23 7.811364e-23 -3.444     1     1        0     setosa #> Petal.Width    1.325346e-23 5.301384e-23 -1.430     1     1        0     setosa #> Sepal.Width.1  3.919743e-09 1.567897e-08 -0.431     1     1        0 versicolor #> Petal.Length.1 8.606063e-01 1.000000e+00  0.753     1     1        0 versicolor #> Sepal.Length.1 1.150950e-14 4.603801e-14  1.117     1     1        0  virginica #> Petal.Length.2 1.150453e-22 4.601814e-22  2.691     1     1        0  virginica #> Petal.Width.1  9.465312e-23 3.786125e-22  1.240     1     1        0  virginica #>                      marker #> Sepal.Length   Sepal.Length #> Sepal.Width     Sepal.Width #> Petal.Length   Petal.Length #> Petal.Width     Petal.Width #> Sepal.Width.1   Sepal.Width #> Petal.Length.1 Petal.Length #> Sepal.Length.1 Sepal.Length #> Petal.Length.2 Petal.Length #> Petal.Width.1   Petal.Width"},{"path":"https://elolab.github.io/Coralysis/reference/FindBatchKNN.html","id":null,"dir":"Reference","previous_headings":"","what":"Find batch k nearest neighbors — FindBatchKNN","title":"Find batch k nearest neighbors — FindBatchKNN","text":"function finds batch k nearest neighbors cell highest probability every batch.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindBatchKNN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find batch k nearest neighbors — FindBatchKNN","text":"","code":"FindBatchKNN(idx, group, prob, k = 10)"},{"path":"https://elolab.github.io/Coralysis/reference/FindBatchKNN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find batch k nearest neighbors — FindBatchKNN","text":"idx numeric vector cell ids retrieve data set. group character vector batch labels corresponding idx. prob numeric vector cell probabilities corresponding idx. k number nearest neighbors search . Default 10.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindBatchKNN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find batch k nearest neighbors — FindBatchKNN","text":"list containing k nearest neighbors every cell queried","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterBatchKNN.html","id":null,"dir":"Reference","previous_headings":"","what":"Find batch k nearest neighbors per cluster — FindClusterBatchKNN","title":"Find batch k nearest neighbors per cluster — FindClusterBatchKNN","text":"function finds batch k nearest neighbors cell highest probability every batch per cluster.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterBatchKNN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find batch k nearest neighbors per cluster — FindClusterBatchKNN","text":"","code":"FindClusterBatchKNN(preds, probs, batch, k = 10, k.prop = NULL)"},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterBatchKNN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find batch k nearest neighbors per cluster — FindClusterBatchKNN","text":"preds numeric vector cell cluster predictions. probs numeric matrix cell cluster probabilities. batch character batch labels. k number nearest neighbors search . Default 10. k.prop numeric (higher 0 lower 1) corresponding fraction cells per cluster use k nearest neighbors. Default NULL meaning number k nearest neighbors equal k. given, k parameter ignored k calculated based k.prop.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterBatchKNN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find batch k nearest neighbors per cluster — FindClusterBatchKNN","text":"list containing k nearest neighbors every cluster","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterMarkers.html","id":null,"dir":"Reference","previous_headings":"","what":"Differential expression between cell clusters — FindClusterMarkers","title":"Differential expression between cell clusters — FindClusterMarkers","text":"FindClusterMarkers enables identifying feature markers one cluster two arbitrary combinations clusters, e.g. 1_2 vs. 3_4_5. Feature cell filters can applied accelerate analysis, might lead missing weak signals.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterMarkers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differential expression between cell clusters — FindClusterMarkers","text":"","code":"FindClusterMarkers.SingleCellExperiment(   object,   clustering.label,   clusters.1,   clusters.2,   test,   log2fc.threshold,   min.pct,   min.diff.pct,   min.cells.group,   max.cells.per.cluster,   return.thresh,   only.pos )  # S4 method for class 'SingleCellExperiment' FindClusterMarkers(   object,   clustering.label,   clusters.1 = NULL,   clusters.2 = NULL,   test = \"wilcox\",   log2fc.threshold = 0.25,   min.pct = 0.1,   min.diff.pct = NULL,   min.cells.group = 3,   max.cells.per.cluster = NULL,   return.thresh = 0.01,   only.pos = FALSE )"},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterMarkers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differential expression between cell clusters — FindClusterMarkers","text":"object SingleCellExperiment object. clustering.label variable name (class character) available cell metadata colData(object) clustering labels (character factor) use. clusters.1 character numeric vector denoting clusters use first group (named group.1 results) clusters.2 character numeric vector denoting clusters use second group (named group.2 results) test test use. \"wilcoxon\" (Wilcoxon rank-sum test, AKA Mann-Whitney U test) supported moment. log2fc.threshold Filters features log2 fold-change averaged feature expression values threshold. Default 0.25. min.pct Filters features dropout rate (fraction cells expressing feature) threshold comparison groups Default 0.1. min.diff.pct Filters features minimum difference dropout rates (fraction cells expressing feature) two comparison groups. Default NULL. min.cells.group minimum number cells two comparison groups perform DE analysis. number cells threshold, DE analysis performed. Default 3. max.cells.per.cluster maximun number cells per cluster downsampling performed speed DE analysis. Default NULL, .e. downsampling. return.thresh .pos=TRUE, return features adjusted p-value (adjusted Bonferroni method) equal threshold.  Default 0.01. .pos Whether return features adjusted p-value (adjusted Bonferroni method) equal threshold. Default FALSE.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterMarkers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Differential expression between cell clusters — FindClusterMarkers","text":"data frame results positive results found, else NULL","code":""},{"path":"https://elolab.github.io/Coralysis/reference/FindClusterMarkers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Differential expression between cell clusters — FindClusterMarkers","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Markers between versicolor vs virginica dge <- FindClusterMarkers(sce, clustering.label = \"Species\",                            clusters.1 = \"versicolor\",                            clusters.2 = \"virginica\") #> testing cluster group.1 #> 4 features left after min.pct filtering #> 4 features left after min.diff.pct filtering #> 3 features left after log2fc.threshold filtering dge #>                   p.value  adj.p.value log2FC pct.1 pct.2 diff.pct       marker #> Sepal.Length 5.869006e-07 2.347603e-06 -0.652     1     1        0 Sepal.Length #> Petal.Length 9.133545e-17 3.653418e-16 -1.292     1     1        0 Petal.Length #> Petal.Width  9.698045e-17 3.879218e-16 -0.700     1     1        0  Petal.Width"},{"path":"https://elolab.github.io/Coralysis/reference/GetCellClusterProbability.html","id":null,"dir":"Reference","previous_headings":"","what":"Get ICP cell cluster probability — GetCellClusterProbability","title":"Get ICP cell cluster probability — GetCellClusterProbability","text":"Get ICP cell cluster probability table(s)","code":""},{"path":"https://elolab.github.io/Coralysis/reference/GetCellClusterProbability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get ICP cell cluster probability — GetCellClusterProbability","text":"","code":"GetCellClusterProbability.SingleCellExperiment(   object,   icp.run,   icp.round,   concatenate )  # S4 method for class 'SingleCellExperiment' GetCellClusterProbability(   object,   icp.run = NULL,   icp.round = NULL,   concatenate = TRUE )"},{"path":"https://elolab.github.io/Coralysis/reference/GetCellClusterProbability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get ICP cell cluster probability — GetCellClusterProbability","text":"object object SingleCellExperiment class ICP cell cluster probability tables saved metadata(object)$coralysis$joint.probability. running RunParallelDivisiveICP. icp.run ICP run(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved. Specify numeric vector retrieve specific set tables. icp.round ICP round(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved. concatenate Concatenate list ICP cell cluster probability tables retrieved. default TRUE, .e., list ICP cell cluster probability tables concatenated.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/GetCellClusterProbability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get ICP cell cluster probability — GetCellClusterProbability","text":"list ICP cell cluster probability tables matrix concatenated tables.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/GetCellClusterProbability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get ICP cell cluster probability — GetCellClusterProbability","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Prepare SCE object for analysis sce <- PrepareData(sce) #> Converting object of `matrix` class into `dgCMatrix`. Please note that Coralysis has been designed to work with sparse data, i.e. data with a high proportion of zero values! Dense data will likely increase run time and memory usage drastically! #> 4/4 features remain after filtering features with only zero values.  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"Batch\",                                k = 2, L = 25, C = 1, train.k.nn = 10,                                train.k.nn.prop = NULL, use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                               threads = 2) #>  #> Initializing divisive ICP clustering... #>    |                                                                               |                                                                      |   0%   |                                                                               |===                                                                   |   4%   |                                                                               |======                                                                |   8%   |                                                                               |=========                                                             |  12%   |                                                                               |============                                                          |  17%   |                                                                               |===============                                                       |  21%   |                                                                               |==================                                                    |  25%   |                                                                               |====================                                                  |  29%   |                                                                               |=======================                                               |  33%   |                                                                               |==========================                                            |  38%   |                                                                               |=============================                                         |  42%   |                                                                               |================================                                      |  46%   |                                                                               |===================================                                   |  50%   |                                                                               |======================================                                |  54%   |                                                                               |=========================================                             |  58%   |                                                                               |============================================                          |  62%   |                                                                               |===============================================                       |  67%   |                                                                               |==================================================                    |  71%   |                                                                               |====================================================                  |  75%   |                                                                               |=======================================================               |  79%   |                                                                               |==========================================================            |  83%   |                                                                               |=============================================================         |  88%   |                                                                               |================================================================      |  92%   |                                                                               |===================================================================   |  96%   |                                                                               |======================================================================| 100% #>  #> Divisive ICP clustering completed successfully. #>  #> Predicting cell cluster probabilities using ICP models... #> Prediction of cell cluster probabilities completed successfully. #>  #> Multi-level integration completed successfully.  # Get cluster probability for all ICP runs  probs <- GetCellClusterProbability(object = sce, icp.round = 1, concatenate = TRUE)  probs[1:10, 1:5] #>                1          2         1          2          1 #> samp1  0.9643473 0.03565274 0.9638023 0.03619770 0.03965366 #> samp2  0.9264623 0.07353774 0.9255917 0.07440832 0.08002244 #> samp3  0.9519228 0.04807721 0.9512637 0.04873629 0.05290241 #> samp4  0.9268923 0.07310768 0.9260116 0.07398839 0.07971891 #> samp5  0.9692441 0.03075587 0.9687533 0.03124672 0.03435248 #> samp6  0.9698052 0.03019485 0.9693037 0.03069632 0.03394382 #> samp7  0.9587039 0.04129606 0.9581008 0.04189923 0.04573415 #> samp8  0.9524988 0.04750117 0.9518274 0.04817258 0.05249006 #> samp9  0.9153487 0.08465131 0.9144061 0.08559393 0.09170199 #> samp10 0.9268923 0.07310768 0.9260116 0.07398839 0.07971891"},{"path":"https://elolab.github.io/Coralysis/reference/GetFeatureCoefficients.html","id":null,"dir":"Reference","previous_headings":"","what":"Get feature coefficients — GetFeatureCoefficients","title":"Get feature coefficients — GetFeatureCoefficients","text":"Get feature coefficients ICP models.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/GetFeatureCoefficients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get feature coefficients — GetFeatureCoefficients","text":"","code":"GetFeatureCoefficients.SingleCellExperiment(   object,   icp.run = NULL,   icp.round = NULL )  # S4 method for class 'SingleCellExperiment' GetFeatureCoefficients(object, icp.run = NULL, icp.round = NULL)"},{"path":"https://elolab.github.io/Coralysis/reference/GetFeatureCoefficients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get feature coefficients — GetFeatureCoefficients","text":"object object SingleCellExperiment class ICP cell cluster probability tables saved metadata(object)$coralysis$joint.probability. running RunParallelDivisiveICP. icp.run ICP run(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved. Specify numeric vector retrieve specific set tables. icp.round ICP round(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/GetFeatureCoefficients.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get feature coefficients — GetFeatureCoefficients","text":"list feature coefficient weights per cluster per ICP run/round.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/GetFeatureCoefficients.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get feature coefficients — GetFeatureCoefficients","text":"","code":"if (FALSE) { # \\dontrun{ # Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Import data from Zenodo data.url <- \"https://zenodo.org/records/14845751/files/pbmc_10Xassays.rds?download=1\" sce <- readRDS(file = url(data.url))  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"batch\",                                k = 4, L = 10, C = 1, d = 0.5,                                train.with.bnn = FALSE, use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                                threads = 2)  # GetFeatureCoefficients gene_coefficients_icp_2_4 <- GetFeatureCoefficients(object = sce,                                                      icp.run = 2, icp.round = 4) head(gene_coefficients_icp_2_4$icp_8) } # }"},{"path":"https://elolab.github.io/Coralysis/reference/HeatmapFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"Heatmap visualization of the expression of features by clusters — HeatmapFeatures","title":"Heatmap visualization of the expression of features by clusters — HeatmapFeatures","text":"HeatmapFeatures function draws heatmap features cluster identity.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/HeatmapFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heatmap visualization of the expression of features by clusters — HeatmapFeatures","text":"","code":"HeatmapFeatures.SingleCellExperiment(   object,   clustering.label,   features,   use.color,   seed.color,   ... )  # S4 method for class 'SingleCellExperiment' HeatmapFeatures(   object,   clustering.label,   features,   use.color = NULL,   seed.color = 123,   ... )"},{"path":"https://elolab.github.io/Coralysis/reference/HeatmapFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heatmap visualization of the expression of features by clusters — HeatmapFeatures","text":"object SingleCellExperiment class clustering.label variable name (class character) available cell metadata colData(object) clustering labels (character factor) use. features Feature names plot cluster (character) matching row.names(object). use.color Character specifying colors clusters. default NULL, .e., colors randomly chosen based seed given seed.color. overwritten case argument annotation_colors provided. seed.color Seed randomly select colors clusters. default 123. overwritten case argument annotation_colors provided. ... Parameters pass pheatmap::pheatmap function.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/HeatmapFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heatmap visualization of the expression of features by clusters — HeatmapFeatures","text":"nothing","code":""},{"path":"https://elolab.github.io/Coralysis/reference/HeatmapFeatures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Heatmap visualization of the expression of features by clusters — HeatmapFeatures","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                  \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Plot features by clustering, i.e., grouping variable # without scaling rows (using 'logcounts' expression):  HeatmapFeatures(object = sce, clustering.label = \"Species\",                  features = row.names(sce)[1:4])   # scaling rows:  HeatmapFeatures(object = sce, clustering.label = \"Species\",                  features = row.names(sce)[1:4], scale = \"row\") # scale"},{"path":"https://elolab.github.io/Coralysis/reference/LogisticRegression.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering projection using logistic regression from the LiblineaR R package — LogisticRegression","title":"Clustering projection using logistic regression from the LiblineaR R package — LogisticRegression","text":"function implements script downsamples data dataset, trains logistic regression classifier model projects clustering onto using trained L1-regularized logistic regression model.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/LogisticRegression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering projection using logistic regression from the LiblineaR R package — LogisticRegression","text":"","code":"LogisticRegression(   training.sparse.matrix = NULL,   training.ident = NULL,   C = 0.3,   reg.type = \"L1\",   test.sparse.matrix = NULL,   d = 0.3,   batch.label = NULL,   training_ident_subset = NULL )"},{"path":"https://elolab.github.io/Coralysis/reference/LogisticRegression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering projection using logistic regression from the LiblineaR R package — LogisticRegression","text":"training.sparse.matrix sparse matrix (dgCMatrix) containing training sample's feature expression data features rows cells columns. Default NULL. training.ident named factor containing sample's cluster labels cell training.sparse.matrix. Default NULL. C Cost constraints violation L1-regularized logistic regression (C). Default 0.3. reg.type \"L1\" LASSO \"L2\" Ridge. Default \"L1\". test.sparse.matrix sparse matrix (dgCMatrix) containing test sample's feature expression data features rows cells columns. Default NULL. d numeric smaller 1 greater 0 determines many cells per cluster - oversampled (d N/k*d), N total number cells k number clusters. Default 0.3. batch.label character vector batch labels corresponding cells given training.ident. character batch labels need named cells names given training.ident. default NULL, .e., cells sampled evenly regardless batch. training_ident_subset character numeric vector cell ids use train set. default NULL. given, - oversampled parameters ignored.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/LogisticRegression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering projection using logistic regression from the LiblineaR R package — LogisticRegression","text":"list containing output LiblineaR prediction","code":""},{"path":"https://elolab.github.io/Coralysis/reference/MajorityVotingFeatures.html","id":null,"dir":"Reference","previous_headings":"","what":"Majority voting features by label — MajorityVotingFeatures","title":"Majority voting features by label — MajorityVotingFeatures","text":"Get ICP feature coefficients label interest majority voting label across ICP clusters.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/MajorityVotingFeatures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Majority voting features by label — MajorityVotingFeatures","text":"","code":"MajorityVotingFeatures.SingleCellExperiment(object, label)  # S4 method for class 'SingleCellExperiment' MajorityVotingFeatures(object, label)"},{"path":"https://elolab.github.io/Coralysis/reference/MajorityVotingFeatures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Majority voting features by label — MajorityVotingFeatures","text":"object object SingleCellExperiment class ICP cell cluster probability tables saved metadata(object)$coralysis$joint.probability. running RunParallelDivisiveICP. label Label interest available colData(object).","code":""},{"path":"https://elolab.github.io/Coralysis/reference/MajorityVotingFeatures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Majority voting features by label — MajorityVotingFeatures","text":"list list data frames feature weights per label data frame summary label.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/MajorityVotingFeatures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Majority voting features by label — MajorityVotingFeatures","text":"","code":"if (FALSE) { # \\dontrun{ # Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Import data from Zenodo data.url <- \"https://zenodo.org/records/14845751/files/pbmc_10Xassays.rds?download=1\" sce <- readRDS(file = url(data.url))  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"batch\",                                k = 4, L = 10, C = 1, d = 0.5,                                train.with.bnn = FALSE, use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                                threads = 2)  # Get coefficients by majority voting for a given categorical variable coeff <- MajorityVotingFeatures(object = sce, label = \"cell_type\") gene_coeff$summary order.rows <- order(coeff$feature_coeff$Monocyte$coeff_clt2,                      decreasing = TRUE) head(coeff$feature_coeff$Monocyte[order.rows,], n = 10) } # }"},{"path":"https://elolab.github.io/Coralysis/reference/PCAElbowPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Elbow plot of the standard deviations of the principal components — PCAElbowPlot","title":"Elbow plot of the standard deviations of the principal components — PCAElbowPlot","text":"Draw elbow plot standard deviations principal components deduce appropriate value p.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PCAElbowPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elbow plot of the standard deviations of the principal components — PCAElbowPlot","text":"","code":"PCAElbowPlot.SingleCellExperiment(object, dimred.name, return.plot)  # S4 method for class 'SingleCellExperiment' PCAElbowPlot(object, dimred.name = \"PCA\", return.plot = FALSE)"},{"path":"https://elolab.github.io/Coralysis/reference/PCAElbowPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elbow plot of the standard deviations of the principal components — PCAElbowPlot","text":"object SingleCellExperiment object obtained running RunParallelDivisiveICP. dimred.name Dimensional reduction name PCA select reducedDimNames(object). default \"PCA\". return.plot logical indicating ggplot2 object returned. default FALSE.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PCAElbowPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elbow plot of the standard deviations of the principal components — PCAElbowPlot","text":"ggplot2 object, return.plot=TRUE.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PCAElbowPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Elbow plot of the standard deviations of the principal components — PCAElbowPlot","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Prepare SCE object for analysis sce <- PrepareData(sce) #> Converting object of `matrix` class into `dgCMatrix`. Please note that Coralysis has been designed to work with sparse data, i.e. data with a high proportion of zero values! Dense data will likely increase run time and memory usage drastically! #> 4/4 features remain after filtering features with only zero values.  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"Batch\",                                k = 2, L = 25, C = 1, train.k.nn = 10,                                train.k.nn.prop = NULL, use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                               threads = 2) #>  #> Initializing divisive ICP clustering... #>    |                                                                               |                                                                      |   0%   |                                                                               |===                                                                   |   4%   |                                                                               |======                                                                |   8%   |                                                                               |=========                                                             |  12%   |                                                                               |============                                                          |  17%   |                                                                               |===============                                                       |  21%   |                                                                               |==================                                                    |  25%   |                                                                               |====================                                                  |  29%   |                                                                               |=======================                                               |  33%   |                                                                               |==========================                                            |  38%   |                                                                               |=============================                                         |  42%   |                                                                               |================================                                      |  46%   |                                                                               |===================================                                   |  50%   |                                                                               |======================================                                |  54%   |                                                                               |=========================================                             |  58%   |                                                                               |============================================                          |  62%   |                                                                               |===============================================                       |  67%   |                                                                               |==================================================                    |  71%   |                                                                               |====================================================                  |  75%   |                                                                               |=======================================================               |  79%   |                                                                               |==========================================================            |  83%   |                                                                               |=============================================================         |  88%   |                                                                               |================================================================      |  92%   |                                                                               |===================================================================   |  96%   |                                                                               |======================================================================| 100% #>  #> Divisive ICP clustering completed successfully. #>  #> Predicting cell cluster probabilities using ICP models... #> Prediction of cell cluster probabilities completed successfully. #>  #> Multi-level integration completed successfully.  # Integrated PCA set.seed(125) # to ensure reproducibility for the default 'irlba' method sce <- RunPCA(object = sce, assay.name = \"joint.probability\", p = 10) #> Divisive ICP: selecting ICP tables multiple of 1  # Plot result  cowplot::plot_grid(PlotDimRed(object = sce, color.by = \"Batch\",                                legend.nrow = 1),                    PlotDimRed(object = sce, color.by = \"Species\",                               legend.nrow = 1), ncol = 2)   # Plot Elbow PCAElbowPlot(sce)"},{"path":"https://elolab.github.io/Coralysis/reference/PlotClusterTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot cluster tree — PlotClusterTree","title":"Plot cluster tree — PlotClusterTree","text":"Plot cluster tree cluster probability categorical variable.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotClusterTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot cluster tree — PlotClusterTree","text":"","code":"PlotClusterTree.SingleCellExperiment(   object,   icp.run,   color.by,   use.color,   seed.color,   legend.title,   return.data )  # S4 method for class 'SingleCellExperiment' PlotClusterTree(   object,   icp.run,   color.by = NULL,   use.color = NULL,   seed.color = 123,   legend.title = color.by,   return.data = FALSE )"},{"path":"https://elolab.github.io/Coralysis/reference/PlotClusterTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot cluster tree — PlotClusterTree","text":"object object SingleCellExperiment class. icp.run ICP run(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved. Specify numeric vector retrieve specific set tables. color.Categorical variable available colData(object) plot. NULL cluster probability represented instead. default NULL. use.color Character specifying colors. default NULL, .e., colors randomly chosen based seed given seed.color. seed.color Seed randomly select colors. default 123. legend.title Legend title. default given color.. Ignored color.NULL. return.data Return data frame used plot. Logical. default FALSE, .e., plot returned.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotClusterTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot cluster tree — PlotClusterTree","text":"plot class ggplot list plot class ggplot data frame.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotClusterTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot cluster tree — PlotClusterTree","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                  \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Prepare SCE object for analysis sce <- PrepareData(sce) #> Converting object of `matrix` class into `dgCMatrix`. Please note that Coralysis has been designed to work with sparse data, i.e. data with a high proportion of zero values! Dense data will likely increase run time and memory usage drastically! #> 4/4 features remain after filtering features with only zero values.  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"Batch\", k = 4,                                L = 25, C = 1, d = 0.5, train.with.bnn = FALSE,                                use.cluster.seed = FALSE, build.train.set = FALSE,                                ari.cutoff = 0.1, threads = 2) #>  #> Initializing divisive ICP clustering... #>    |                                                                               |                                                                      |   0%   |                                                                               |===                                                                   |   4%   |                                                                               |======                                                                |   8%   |                                                                               |=========                                                             |  12%   |                                                                               |============                                                          |  17%   |                                                                               |===============                                                       |  21%   |                                                                               |==================                                                    |  25%   |                                                                               |====================                                                  |  29%   |                                                                               |=======================                                               |  33%   |                                                                               |==========================                                            |  38%   |                                                                               |=============================                                         |  42%   |                                                                               |================================                                      |  46%   |                                                                               |===================================                                   |  50%   |                                                                               |======================================                                |  54%   |                                                                               |=========================================                             |  58%   |                                                                               |============================================                          |  62%   |                                                                               |===============================================                       |  67%   |                                                                               |==================================================                    |  71%   |                                                                               |====================================================                  |  75%   |                                                                               |=======================================================               |  79%   |                                                                               |==========================================================            |  83%   |                                                                               |=============================================================         |  88%   |                                                                               |================================================================      |  92%   |                                                                               |===================================================================   |  96%   |                                                                               |======================================================================| 100% #>  #> Divisive ICP clustering completed successfully. #>  #> Predicting cell cluster probabilities using ICP models... #> Prediction of cell cluster probabilities completed successfully. #>  #> Multi-level integration completed successfully.  # Plot probability PlotClusterTree(object = sce, icp.run = 2)   # Plot batch label distribution PlotClusterTree(object = sce, icp.run = 2, color.by = \"Batch\")   # Plot species label distribution PlotClusterTree(object = sce, icp.run = 2, color.by = \"Species\")"},{"path":"https://elolab.github.io/Coralysis/reference/PlotDimRed.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot dimensional reduction categorical variables — PlotDimRed","title":"Plot dimensional reduction categorical variables — PlotDimRed","text":"Plot categorical variables dimensional reduction.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotDimRed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot dimensional reduction categorical variables — PlotDimRed","text":"","code":"PlotDimRed.SingleCellExperiment(   object,   color.by,   dimred,   dims,   use.color,   point.size,   point.stroke,   legend.nrow,   seed.color,   label,   plot.theme,   rasterise,   rasterise.dpi,   legend.justification,   legend.size,   legend.title )  # S4 method for class 'SingleCellExperiment' PlotDimRed(   object,   color.by,   dimred = tail(reducedDimNames(object), n = 1),   dims = 1:2,   use.color = NULL,   point.size = 1,   point.stroke = 1,   legend.nrow = 2,   seed.color = 123,   label = FALSE,   plot.theme = theme_classic(),   rasterise = (ncol(object) <= 30000),   rasterise.dpi = 300,   legend.justification = \"center\",   legend.size = 10,   legend.title = color.by )"},{"path":"https://elolab.github.io/Coralysis/reference/PlotDimRed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot dimensional reduction categorical variables — PlotDimRed","text":"object object SingleCellExperiment class. color.Categorical variable available colData(object) plot. dimred Dimensional reduction available ReducedDimNames(object) plot. default last dimensional reduction object used. dims Dimensions dimensional reduction embedding plot. use.color Character specifying colors. default NULL, .e., colors randomly chosen based seed given seed.color. point.size Size points. default 1. point.stroke Size stroke. default 1. legend.nrow Display legend items number rows. default 2. seed.color Seed randomly select colors. default 123. label Logical add categorical labels centroid categories. default FALSE, .e., labels added. plot.theme Plot theme available ggplot2. default theme_classic(). rasterise Logical specifying points rasterised . default TRUE, 3e4 cells, otherwise FALSE. rasterise.dpi case rasterise = TRUE, DPI use. default 300. legend.justification Legend justification. default \"center\". legend.size Legend size. default 10 legend.title Legend title. default given color..","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotDimRed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot dimensional reduction categorical variables — PlotDimRed","text":"plot class ggplot.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotDimRed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot dimensional reduction categorical variables — PlotDimRed","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                            colData = DataFrame(\"Species\" = iris$Species,                                               \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Compute dimensional reduction  sce <- RunPCA(object = sce, assay.name = \"logcounts\", p = 4,              pca.method = \"stats\")  # Plot batch  PlotDimRed(object = sce, color.by = \"Batch\", dimred = \"PCA\", legend.nrow = 1)   # Plot cell type annotations PlotDimRed(object = sce, color.by = \"Species\", legend.nrow = 1,            dimred = \"PCA\", label = TRUE) #> Warning: Removed 147 rows containing missing values or values outside the scale range #> (`geom_text_repel()`)."},{"path":"https://elolab.github.io/Coralysis/reference/PlotExpression.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot dimensional reduction feature expression — PlotExpression","title":"Plot dimensional reduction feature expression — PlotExpression","text":"Plot feature expression dimensional reduction.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotExpression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot dimensional reduction feature expression — PlotExpression","text":"","code":"PlotExpression.SingleCellExperiment(   object,   color.by,   dimred,   scale.values,   color.scale,   plot.theme,   legend.title,   point.size,   point.stroke )  # S4 method for class 'SingleCellExperiment' PlotExpression(   object,   color.by,   dimred = tail(reducedDimNames(object), n = 1),   scale.values = FALSE,   color.scale = \"inferno\",   plot.theme = theme_classic(),   legend.title = color.by,   point.size = 1,   point.stroke = 1 )"},{"path":"https://elolab.github.io/Coralysis/reference/PlotExpression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot dimensional reduction feature expression — PlotExpression","text":"object object SingleCellExperiment class. color.Categorical variable available colData(object) plot. dimred Dimensional reduction available ReducedDimNames(object) plot. default last dimensional reduction object used. scale.values Logical specifying values scaled. default FALSE, .e., values scaled. color.scale Character color scale palette passed ggplot2::scale_color_viridis_c. default inferno. palettes also available viridis. plot.theme Plot theme available ggplot2. default theme_classic(). legend.title Legend title. default given color.. point.size Size points. default 1. point.stroke Size stroke. default 1.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotExpression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot dimensional reduction feature expression — PlotExpression","text":"plot class ggplot.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PlotExpression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot dimensional reduction feature expression — PlotExpression","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                              colData = DataFrame(\"Species\" = iris$Species,                                               \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Compute dimensional reduction  sce <- RunPCA(object = sce, assay.name = \"logcounts\", p = 4,             pca.method = \"stats\")  # Plot expression level of one or more features ## one  PlotExpression(object = sce, color.by = \"Petal.Width\")   ## more than one features <- row.names(sce)[1:4]  exp.plots <- lapply(X = features, FUN = function(x) {     PlotExpression(object = sce, color.by = x, scale.values = TRUE) }) cowplot::plot_grid(plotlist = exp.plots, ncol = 2, align = \"vh\")"},{"path":"https://elolab.github.io/Coralysis/reference/PrepareData.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare SingleCellExperiment object for analysis — PrepareData","title":"Prepare SingleCellExperiment object for analysis — PrepareData","text":"function prepares SingleCellExperiment object analysis. required input object class SingleCellExperiment least data logcounts slot.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PrepareData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare SingleCellExperiment object for analysis — PrepareData","text":"","code":"PrepareData.SingleCellExperiment(object)  # S4 method for class 'SingleCellExperiment' PrepareData(object)"},{"path":"https://elolab.github.io/Coralysis/reference/PrepareData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare SingleCellExperiment object for analysis — PrepareData","text":"object object SingleCellExperiment class.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PrepareData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare SingleCellExperiment object for analysis — PrepareData","text":"object SingleCellExperiment class.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/PrepareData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare SingleCellExperiment object for analysis — PrepareData","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce)) sce <- PrepareData(sce) #> Converting object of `matrix` class into `dgCMatrix`. Please note that Coralysis has been designed to work with sparse data, i.e. data with a high proportion of zero values! Dense data will likely increase run time and memory usage drastically! #> 4/4 features remain after filtering features with only zero values."},{"path":"https://elolab.github.io/Coralysis/reference/RandomlyDivisiveClustering.html","id":null,"dir":"Reference","previous_headings":"","what":"Split randomly every cluster into k clusters — RandomlyDivisiveClustering","title":"Split randomly every cluster into k clusters — RandomlyDivisiveClustering","text":"Splits randomly every cluster given k clusters","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RandomlyDivisiveClustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split randomly every cluster into k clusters — RandomlyDivisiveClustering","text":"","code":"RandomlyDivisiveClustering(cluster, k, cluster.names = NULL)"},{"path":"https://elolab.github.io/Coralysis/reference/RandomlyDivisiveClustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split randomly every cluster into k clusters — RandomlyDivisiveClustering","text":"cluster clustering result cluster divided randomly k clusters. k number clusters cluster given cluster randomly divided . cluster.names Names name cluster result given. default NULL.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RandomlyDivisiveClustering.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split randomly every cluster into k clusters — RandomlyDivisiveClustering","text":"clustering result every cluster given split randomly k clusters.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ReferenceMapping.html","id":null,"dir":"Reference","previous_headings":"","what":"Reference mapping — ReferenceMapping","title":"Reference mapping — ReferenceMapping","text":"function allows project new query data sets onto reference built Coralysis well transfer cell labels reference queries.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ReferenceMapping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reference mapping — ReferenceMapping","text":"","code":"ReferenceMapping.SingleCellExperiment(   ref,   query,   ref.label,   scale.query.by,   project.umap,   select.icp.models,   k.nn,   dimred.name.prefix )  # S4 method for class 'SingleCellExperiment,SingleCellExperiment' ReferenceMapping(   ref,   query,   ref.label,   scale.query.by = NULL,   project.umap = FALSE,   select.icp.models = metadata(ref)$coralysis$pca.params$select.icp.tables,   k.nn = 10,   dimred.name.prefix = \"\" )"},{"path":"https://elolab.github.io/Coralysis/reference/ReferenceMapping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reference mapping — ReferenceMapping","text":"ref object SingleCellExperiment class trained Coralysis running RunPCA(..., return.model = TRUE) function. query object SingleCellExperiment class project onto ref. ref.label character cell metadata column name ref object transfer queries. scale.query.query data scaled cell feature. default NULL, .e., scaled. Scale reference scaled. project.umap Project query data onto reference UMAP (logical). default FALSE. TRUE, ref object needs UMAP embedding obtained RunUMAP(..., return.model = TRUE) function. select.icp.models Select reference ICP models use query cluster probability prediction. default metadata(ref)$coralysis$pca.params$select.icp.tables, .e., models selected compute reference PCA selected. NULL used. Otherwise numeric vector given select ICP models interest. k.nn number k nearest neighbors use classification KNN algorithm used transfer labels reference queries (integer). default 10. dimred.name.prefix Dimensional reduction name prefix add computed PCA UMAP. default nothing added, .e., dimred.name.prefix = \"\".","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ReferenceMapping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reference mapping — ReferenceMapping","text":"object SingleCellExperiment class.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ReferenceMapping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reference mapping — ReferenceMapping","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                              colData = DataFrame(\"Species\" = iris$Species,                                                  \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Create reference & query SCE objects ref <- sce[,sce$Batch==\"b1\"] query <- sce[,sce$Batch==\"b2\"]  # 1) Train the reference set.seed(123) ref <- RunParallelDivisiveICP(object = ref, k = 2, L = 25, C = 1,                               train.k.nn = 10, train.k.nn.prop = NULL,                               use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                               threads = 2)  #> WARNING: Setting 'divisive.method' to 'cluster' as 'batch.label=NULL'.  #> If 'batch.label=NULL', 'divisive.method' can be one of: 'cluster', 'random'.  #>  #> Initializing divisive ICP clustering... #>    |                                                                               |                                                                      |   0%   |                                                                               |===                                                                   |   4%   |                                                                               |======                                                                |   8%   |                                                                               |=========                                                             |  12%   |                                                                               |============                                                          |  17%   |                                                                               |===============                                                       |  21%   |                                                                               |==================                                                    |  25%   |                                                                               |====================                                                  |  29%   |                                                                               |=======================                                               |  33%   |                                                                               |==========================                                            |  38%   |                                                                               |=============================                                         |  42%   |                                                                               |================================                                      |  46%   |                                                                               |===================================                                   |  50%   |                                                                               |======================================                                |  54%   |                                                                               |=========================================                             |  58%   |                                                                               |============================================                          |  62%   |                                                                               |===============================================                       |  67%   |                                                                               |==================================================                    |  71%   |                                                                               |====================================================                  |  75%   |                                                                               |=======================================================               |  79%   |                                                                               |==========================================================            |  83%   |                                                                               |=============================================================         |  88%   |                                                                               |================================================================      |  92%   |                                                                               |===================================================================   |  96%   |                                                                               |======================================================================| 100% #>  #> Divisive ICP clustering completed successfully. #>  #> Predicting cell cluster probabilities using ICP models... #> Prediction of cell cluster probabilities completed successfully. #>  #> Multi-level integration completed successfully. # 2) Compute reference PCA & UMAP ref <- RunPCA(ref, p = 5, return.model = TRUE, pca.method = \"stats\") #> Divisive ICP: selecting ICP tables multiple of 1 set.seed(123) ref <- RunUMAP(ref, return.model = TRUE)  # Plot  PlotDimRed(object = ref, color.by = \"Species\", legend.nrow = 1)   # 3) Project & predict query cell labels   map <- ReferenceMapping(ref = ref, query = query, ref.label = \"Species\",                         project.umap = TRUE)  # Confusion matrix: predictions (rows) x ground-truth (cols) preds_x_truth <- table(map$coral_labels, map$Species) print(preds_x_truth) #>              #>              setosa versicolor virginica #>   setosa         24          0         0 #>   versicolor      0         18         2 #>   virginica       0          2        20  # Accuracy score acc <- sum(diag(preds_x_truth)) / sum(preds_x_truth) * 100   print(paste0(\"Coralysis accuracy score: \", round(acc), \"%\")) #> [1] \"Coralysis accuracy score: 94%\"  # Visualize: ground-truth, prediction, confidence scores cowplot::plot_grid(PlotDimRed(object = map, color.by = \"Species\",                                legend.nrow = 1),                    PlotDimRed(object = map, color.by = \"coral_labels\",                              legend.nrow = 1),                 PlotExpression(object = map, color.by = \"coral_probability\",                                   color.scale = \"viridis\"),                 ncol = 2, align = \"vh\")"},{"path":"https://elolab.github.io/Coralysis/reference/RunDivisiveICP.html","id":null,"dir":"Reference","previous_headings":"","what":"Divisive Iterative Clustering Projection (ICP) clustering — RunDivisiveICP","title":"Divisive Iterative Clustering Projection (ICP) clustering — RunDivisiveICP","text":"function implements divisive Iterative Clustering Projection (ICP) clustering: supervised learning-based clustering, maximizes clustering similarity clustering projection logistic regression, divisive clustering manner.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunDivisiveICP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divisive Iterative Clustering Projection (ICP) clustering — RunDivisiveICP","text":"","code":"RunDivisiveICP(   normalized.data = NULL,   batch.label = NULL,   k = 16,   d = 0.3,   r = 5,   C = 5,   reg.type = \"L1\",   max.iter = 200,   icp.batch.size = Inf,   train.with.bnn = TRUE,   train.k.nn = 10,   train.k.nn.prop = NULL,   cluster.seed = NULL,   divisive.method = \"random\",   allow.free.k = FALSE,   ari.cutoff = 0.5 )"},{"path":"https://elolab.github.io/Coralysis/reference/RunDivisiveICP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divisive Iterative Clustering Projection (ICP) clustering — RunDivisiveICP","text":"normalized.data sparse matrix (dgCMatrix) containing normalized feature expression data cells rows features columns. Default NULL. batch.label character vector batch labels corresponding cells given normalized.data. character batch labels need named cells names given rows normalized.data. default NULL, .e., cells sampled evenly regardless batch. k positive integer power two, .e., 2**n, n>0, specifying number clusters last Iterative Clustering Projection (ICP) round. Decreasing k leads smaller cell populations diversity vice versa. Default 16, .e., divisive clustering 2 -> 4 -> 8 -> 16 performed. d numeric defines many cells per cluster - oversampled (d ceiling(N/k*d)), stratified.downsampling=FALSE, fraction downsampled stratified approach ,stratified.downsampling=TRUE. Default 0.3. r positive integer denotes number reiterations performed algorithm stops. Default 5. C Cost constraints violation (C) L1-regulatization. Default 0.3. reg.type \"L1\" LASSO \"L2\" Ridge. Default \"L1\". max.iter positive integer denotes maximum number iterations performed algorithm ends. Default 200. icp.batch.size positive integer specifies many cells randomly select ICP run complete data set. new feature intended speed process larger data sets. Default Inf, means using cells. train..bnn Train data batch nearest neighbors. Default TRUE. used batch.label given. train.k.nn Train data batch nearest neighbors using k nearest neighbors. Default 10. used train..bnn TRUE. train.k.nn.prop numeric (higher 0 lower 1) corresponding fraction cells per cluster use train.k.nn nearest neighbors. Default NULL meaning number train.k.nn nearest neighbors equal train.k.nn. given, train.k.nn parameter ignored train.k.nn calculated based train.k.nn.prop. vector different proportions different divisive clustering rounds can given, otherwise value given . cluster.seed cluster seed start guide clustering reproducible clusterings across runs (factor). Default NULL. Otherwise, random clustering takes place start divisive clustering ICP. divisive.method Divisive method (character). One \"random\" (randomly sample two clusters every cluster previously found), \"cluster\" \"cluster.batch\" (sample two clusters every cluster previously found based cluster probability distribution across batches per batch). default \"random\". allow.free.k Allow free k (logical). Allow ICP algorithm decrease k given case find k target clusters. default FALSE. ari.cutoff Include ICP models probability tables Adjusted Rand Index higher ari.cutoff (numeric). default 0.5. value can range 0 (include ) lower 1.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunDivisiveICP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divisive Iterative Clustering Projection (ICP) clustering — RunDivisiveICP","text":"list includes probability matrix clustering similarity measures: ARI, NMI, etc.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"Principal Component Analysis — RunPCA","title":"Principal Component Analysis — RunPCA","text":"Perform principal component analysis using assays joint probability matrix input.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunPCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Principal Component Analysis — RunPCA","text":"","code":"RunPCA.SingleCellExperiment(   object,   assay.name,   p,   scale,   center,   threshold,   pca.method,   return.model,   select.icp.tables,   features,   dimred.name )  # S4 method for class 'SingleCellExperiment' RunPCA(   object,   assay.name = \"joint.probability\",   p = 50,   scale = TRUE,   center = TRUE,   threshold = 0,   pca.method = \"irlba\",   return.model = FALSE,   select.icp.tables = NULL,   features = NULL,   dimred.name = \"PCA\" )"},{"path":"https://elolab.github.io/Coralysis/reference/RunPCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Principal Component Analysis — RunPCA","text":"object SingleCellExperiment object. assay.name Name assay compute PCA. One assayNames(object) joint.probability. default joint.probability used. Use joint.probability obtain integrated embedding running RunParallelDivisiveICP. One assays assayNames(object) can provided performing integration assess data requires integration. p positive integer denoting number principal components calculate select. Default 50. scale logical specifying whether probabilities standardized unit-variance running PCA. Default TRUE. center logical specifying whether probabilities centered running PCA. Default TRUE. threshold threshold filtering ICP runs PCA lower terminal projection accuracy threshold. Default 0. pca.method character specifying PCA method. One \"irlba\" (default), \"RSpectra\" \"stats\". Set seed , method \"irlba\" ensure reproducibility. return.model logical specifying PCA model retrieved. default FALSE. implemented pca.method = \"stats\". TRUE, pca.method coerced \"stats\". select.icp.tables Select ICP cluster probability tables perform PCA. default NULL, .e., used, except ICP tables obtained function RunParallelDivisiveICP, ICP tables correspond last round divisive clustering every epoch. vector integers given otherwise. features character feature names matching row.names(object) select computing PCA. used assay.name one assays assayNames(object), otherwise ignored. dimred.name Dimensional reduction name given returned PCA. default \"PCA\".","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunPCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Principal Component Analysis — RunPCA","text":"object SingleCellExperiment class","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunPCA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Principal Component Analysis — RunPCA","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Prepare SCE object for analysis sce <- PrepareData(sce) #> Converting object of `matrix` class into `dgCMatrix`. Please note that Coralysis has been designed to work with sparse data, i.e. data with a high proportion of zero values! Dense data will likely increase run time and memory usage drastically! #> 4/4 features remain after filtering features with only zero values.  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"Batch\",                                k = 2, L = 25, C = 1, train.k.nn = 10,                                train.k.nn.prop = NULL, use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                               threads = 2) #>  #> Initializing divisive ICP clustering... #>    |                                                                               |                                                                      |   0%   |                                                                               |===                                                                   |   4%   |                                                                               |======                                                                |   8%   |                                                                               |=========                                                             |  12%   |                                                                               |============                                                          |  17%   |                                                                               |===============                                                       |  21%   |                                                                               |==================                                                    |  25%   |                                                                               |====================                                                  |  29%   |                                                                               |=======================                                               |  33%   |                                                                               |==========================                                            |  38%   |                                                                               |=============================                                         |  42%   |                                                                               |================================                                      |  46%   |                                                                               |===================================                                   |  50%   |                                                                               |======================================                                |  54%   |                                                                               |=========================================                             |  58%   |                                                                               |============================================                          |  62%   |                                                                               |===============================================                       |  67%   |                                                                               |==================================================                    |  71%   |                                                                               |====================================================                  |  75%   |                                                                               |=======================================================               |  79%   |                                                                               |==========================================================            |  83%   |                                                                               |=============================================================         |  88%   |                                                                               |================================================================      |  92%   |                                                                               |===================================================================   |  96%   |                                                                               |======================================================================| 100% #>  #> Divisive ICP clustering completed successfully. #>  #> Predicting cell cluster probabilities using ICP models... #> Prediction of cell cluster probabilities completed successfully. #>  #> Multi-level integration completed successfully.  # Integrated PCA set.seed(125) # to ensure reproducibility for the default 'irlba' method sce <- RunPCA(object = sce, assay.name = \"joint.probability\", p = 10) #> Divisive ICP: selecting ICP tables multiple of 1  # Plot result  cowplot::plot_grid(PlotDimRed(object = sce, color.by = \"Batch\",                                legend.nrow = 1),                    PlotDimRed(object = sce, color.by = \"Species\",                               legend.nrow = 1), ncol = 2)"},{"path":"https://elolab.github.io/Coralysis/reference/RunParallelDivisiveICP.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-level integration — RunParallelDivisiveICP","title":"Multi-level integration — RunParallelDivisiveICP","text":"Run divisive ICP clustering parallel order perform multi-level integration.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunParallelDivisiveICP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-level integration — RunParallelDivisiveICP","text":"","code":"RunParallelDivisiveICP.SingleCellExperiment(   object,   batch.label,   k,   d,   L,   r,   C,   reg.type,   max.iter,   threads,   icp.batch.size,   train.with.bnn,   train.k.nn,   train.k.nn.prop,   build.train.set,   build.train.params,   scale.by,   use.cluster.seed,   divisive.method,   allow.free.k,   ari.cutoff,   verbose )  # S4 method for class 'SingleCellExperiment' RunParallelDivisiveICP(   object,   batch.label = NULL,   k = 16,   d = 0.3,   L = 50,   r = 5,   C = 0.3,   reg.type = \"L1\",   max.iter = 200,   threads = 0,   icp.batch.size = Inf,   train.with.bnn = TRUE,   train.k.nn = 10,   train.k.nn.prop = 0.3,   build.train.set = TRUE,   build.train.params = list(),   scale.by = NULL,   use.cluster.seed = TRUE,   divisive.method = \"cluster.batch\",   allow.free.k = TRUE,   ari.cutoff = 0.3,   verbose = FALSE )"},{"path":"https://elolab.github.io/Coralysis/reference/RunParallelDivisiveICP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multi-level integration — RunParallelDivisiveICP","text":"object object SingleCellExperiment class. batch.label variable name (class character) available cell metadata colData(object) batch labels (character factor) use. variable provided must contain NAs. default NULL, .e., cells sampled evenly regardless batch. k positive integer power two, .e., 2**n, n>0, specifying number clusters last Iterative Clustering Projection (ICP) round. Decreasing k leads smaller cell populations diversity vice versa. Default 16, .e., divisive clustering 2 -> 4 -> 8 -> 16 performed. d numeric greater 0 smaller 1 determines many cells n - oversampled cluster training data (n=N/k*d), N total number cells, k number clusters ICP. Increasing 0.3 leads greadually smaller cell populations diversity. Default 0.3. L positive integer greater 1 denoting number ICP runs run. Default 50. Increasing recommended significantly larger sample size (tens thousands cells). Default 200. r positive integer denotes number reiterations performed ICP algorithm stops. Increasing recommended significantly larger sample size (tens thousands cells). Default 5. C positive real number denoting cost constraints violation L1-regularized logistic regression model LIBLINEAR library. Decreasing leads stringent feature selection, .e. less features selected used build projection classifier. Decreasing low value (~ 0.01) can lead failure identify central cell populations. Default 0.3. reg.type \"L1\" \"L2\". L2-regularization investigated manuscript, leads conventional outcome (less subpopulations). Default \"L1\". max.iter positive integer denotes maximum number iterations performed ICP stops. parameter useful situations ICP converges extremely slowly, preventing algorithm run long. cases, reaching number reiterations (r=5) terminates algorithm. Default 200. threads positive integer specifies many logical processors (threads) use parallel computation. Set 1 disable parallelism altogether 0 use available threas except one. Default 0. icp.batch.size positive integer specifies many cells randomly select. behaves differently depending build.train.set. build.train.set=FALSE, randomly samples cells ICP run complete dataset. build.train.set=TRUE, randomly samples cells , building training set sampled cells (per batch batch.label different NULL). Default Inf, means using cells. train..bnn Train data batch nearest neighbors. Default TRUE. used batch.label given. train.k.nn Train data batch nearest neighbors using k nearest neighbors. Default 10. used train..bnn TRUE train.k.nn.prop NULL. train.k.nn.prop numeric (higher 0 lower 1) corresponding fraction cells per cluster use train.k.nn nearest neighbors. NULL number train.k.nn nearest neighbors equal train.k.nn. given, train.k.nn parameter ignored train.k.nn calculated based train.k.nn.prop. default 0.3 meaning 30 proportions different divisive clustering rounds can given, otherwise value given . build.train.set Logical specifying training set built data whole data used training. default TRUE. build.train.params list parameters passed function AggregateDataByBatch(). provided build.train.set TRUE. scale.character specifying data scaled cell feature training. Default NULL, .e., data scaled training. use.cluster.seed starting clustering result provided ensure reproducible results (logical). FALSE, ICP run starts total random clustering , thus, independent clustering. default TRUE, .e., clustering result provided based PCA density sampling. batch.label different NULL, PCA density sampling performed batch wise manner. divisive.method Divisive method (character). One \"random\" (randomly sample two clusters every cluster previously found), \"cluster\" \"cluster.batch\" (sample two clusters every cluster previously found based cluster probability distribution across batches per batch). default \"cluster.batch\". batch.label NULL, automatically set cluster. can set random explicitly provided. allow.free.k Allow free k (logical). Allow ICP algorithm decrease k given case find k target clusters. default TRUE. ari.cutoff Include ICP models probability tables Adjusted Rand Index higher ari.cutoff (numeric). default 0.3. value can range 0 (include ) lower 1. verbose logical value print verbose ICP run case parallelization, .e., 'threads' different 1. Default 'FALSE'.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunParallelDivisiveICP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multi-level integration — RunParallelDivisiveICP","text":"SingleCellExperiment object.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunParallelDivisiveICP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-level integration — RunParallelDivisiveICP","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Prepare SCE object for analysis sce <- PrepareData(sce) #> Converting object of `matrix` class into `dgCMatrix`. Please note that Coralysis has been designed to work with sparse data, i.e. data with a high proportion of zero values! Dense data will likely increase run time and memory usage drastically! #> 4/4 features remain after filtering features with only zero values.  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"Batch\",                                k = 2, L = 25, C = 1, train.k.nn = 10,                                train.k.nn.prop = NULL, use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                                threads = 2) #>  #> Initializing divisive ICP clustering... #>    |                                                                               |                                                                      |   0%   |                                                                               |===                                                                   |   4%   |                                                                               |======                                                                |   8%   |                                                                               |=========                                                             |  12%   |                                                                               |============                                                          |  17%   |                                                                               |===============                                                       |  21%   |                                                                               |==================                                                    |  25%   |                                                                               |====================                                                  |  29%   |                                                                               |=======================                                               |  33%   |                                                                               |==========================                                            |  38%   |                                                                               |=============================                                         |  42%   |                                                                               |================================                                      |  46%   |                                                                               |===================================                                   |  50%   |                                                                               |======================================                                |  54%   |                                                                               |=========================================                             |  58%   |                                                                               |============================================                          |  62%   |                                                                               |===============================================                       |  67%   |                                                                               |==================================================                    |  71%   |                                                                               |====================================================                  |  75%   |                                                                               |=======================================================               |  79%   |                                                                               |==========================================================            |  83%   |                                                                               |=============================================================         |  88%   |                                                                               |================================================================      |  92%   |                                                                               |===================================================================   |  96%   |                                                                               |======================================================================| 100% #>  #> Divisive ICP clustering completed successfully. #>  #> Predicting cell cluster probabilities using ICP models... #> Prediction of cell cluster probabilities completed successfully. #>  #> Multi-level integration completed successfully.  # Integrated PCA set.seed(125) # to ensure reproducibility for the default 'irlba' method sce <- RunPCA(object = sce, assay.name = \"joint.probability\", p = 10) #> Divisive ICP: selecting ICP tables multiple of 1  # Plot result  cowplot::plot_grid(PlotDimRed(object = sce, color.by = \"Batch\",                                legend.nrow = 1),                    PlotDimRed(object = sce, color.by = \"Species\",                                legend.nrow = 1), ncol = 2)"},{"path":"https://elolab.github.io/Coralysis/reference/RunTSNE.html","id":null,"dir":"Reference","previous_headings":"","what":"Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding (t-SNE) — RunTSNE","title":"Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding (t-SNE) — RunTSNE","text":"Run nonlinear dimensionality reduction using t-SNE PCA-transformed consensus matrix input.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunTSNE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding (t-SNE) — RunTSNE","text":"","code":"RunTSNE.SingleCellExperiment(   object,   dims,   dimred.type,   perplexity,   dimred.name,   ... )  # S4 method for class 'SingleCellExperiment' RunTSNE(   object,   dims = NULL,   dimred.type = \"PCA\",   perplexity = 30,   dimred.name = \"TSNE\",   ... )"},{"path":"https://elolab.github.io/Coralysis/reference/RunTSNE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding (t-SNE) — RunTSNE","text":"object Object SingleCellExperiment class. dims Dimensions select dimred.type. default NULL, .e., dimensions selected. Provide numeric vector select specific range, e.g., dims = 1:10 select first 10 dimensions. dimred.type Dimensional reduction type use. default \"PCA\". perplexity Perplexity t-SNE. dimred.name Dimensional reduction name given returned t-SNE. default \"TSNE\". ... Parameters passed Rtsne function. parameters given match parameters accepted Rtsne function. Check possible parameters ?Rtsne::Rtsne.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunTSNE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding (t-SNE) — RunTSNE","text":"SingleCellExperiment object.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunTSNE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Barnes-Hut implementation of t-Distributed Stochastic Neighbor Embedding (t-SNE) — RunTSNE","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Run PCA set.seed(125) # to ensure reproducibility for the default 'irlba' method sce <- RunPCA(object = sce, assay.name = \"logcounts\",                pca.method = \"stats\", p = nrow(sce))  # Run t-SNE set.seed(125) # to ensure reproducibility for the default 'irlba' method sce <- RunTSNE(object = sce, dimred.type = \"PCA\", check_duplicates = FALSE)  # Plot result  cowplot::plot_grid(PlotDimRed(object = sce, color.by = \"Batch\",                                legend.nrow = 1),                    PlotDimRed(object = sce, color.by = \"Species\",                               legend.nrow = 1), ncol = 2)"},{"path":"https://elolab.github.io/Coralysis/reference/RunUMAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform Manifold Approximation and Projection (UMAP) — RunUMAP","title":"Uniform Manifold Approximation and Projection (UMAP) — RunUMAP","text":"Run nonlinear dimensionality reduction using UMAP dimensional reduction input.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunUMAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform Manifold Approximation and Projection (UMAP) — RunUMAP","text":"","code":"RunUMAP.SingleCellExperiment(   object,   dims,   dimred.type,   return.model,   umap.method,   dimred.name,   ... )  # S4 method for class 'SingleCellExperiment' RunUMAP(   object,   dims = NULL,   dimred.type = \"PCA\",   return.model = FALSE,   umap.method = \"umap\",   dimred.name = \"UMAP\",   ... )"},{"path":"https://elolab.github.io/Coralysis/reference/RunUMAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform Manifold Approximation and Projection (UMAP) — RunUMAP","text":"object object SingleCellExperiment class. dims Dimensions select dimred.type. default NULL, .e., dimensions selected. Provide numeric vector select specific range, e.g., dims = 1:10 select first 10 dimensions. dimred.type Dimensional reduction type use. default \"PCA\". return.model Return UMAP model. default FALSE. umap.method UMAP method use: \"umap\" \"uwot\". default \"umap\". dimred.name Dimensional reduction name given returned UMAP. default \"UMAP\". ... Parameters passed umap function. parameters given match parameters accepted umap function depending umap.method given. Check possible parameters ?umap::umap ?uwot::umap depending umap.method \"umap\" \"uwot\".","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunUMAP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform Manifold Approximation and Projection (UMAP) — RunUMAP","text":"SingleCellExperiment object.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/RunUMAP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform Manifold Approximation and Projection (UMAP) — RunUMAP","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Prepare SCE object for analysis sce <- PrepareData(sce) #> Converting object of `matrix` class into `dgCMatrix`. Please note that Coralysis has been designed to work with sparse data, i.e. data with a high proportion of zero values! Dense data will likely increase run time and memory usage drastically! #> 4/4 features remain after filtering features with only zero values.  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"Batch\",                                k = 2, L = 25, C = 1, train.k.nn = 10,                                train.k.nn.prop = NULL, use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                               threads = 2) #>  #> Initializing divisive ICP clustering... #>    |                                                                               |                                                                      |   0%   |                                                                               |===                                                                   |   4%   |                                                                               |======                                                                |   8%   |                                                                               |=========                                                             |  12%   |                                                                               |============                                                          |  17%   |                                                                               |===============                                                       |  21%   |                                                                               |==================                                                    |  25%   |                                                                               |====================                                                  |  29%   |                                                                               |=======================                                               |  33%   |                                                                               |==========================                                            |  38%   |                                                                               |=============================                                         |  42%   |                                                                               |================================                                      |  46%   |                                                                               |===================================                                   |  50%   |                                                                               |======================================                                |  54%   |                                                                               |=========================================                             |  58%   |                                                                               |============================================                          |  62%   |                                                                               |===============================================                       |  67%   |                                                                               |==================================================                    |  71%   |                                                                               |====================================================                  |  75%   |                                                                               |=======================================================               |  79%   |                                                                               |==========================================================            |  83%   |                                                                               |=============================================================         |  88%   |                                                                               |================================================================      |  92%   |                                                                               |===================================================================   |  96%   |                                                                               |======================================================================| 100% #>  #> Divisive ICP clustering completed successfully. #>  #> Predicting cell cluster probabilities using ICP models... #> Prediction of cell cluster probabilities completed successfully. #>  #> Multi-level integration completed successfully.  # Integrated PCA set.seed(125) # to ensure reproducibility for the default 'irlba' method sce <- RunPCA(object = sce, assay.name = \"joint.probability\", p = 10) #> Divisive ICP: selecting ICP tables multiple of 1  # Plot result  cowplot::plot_grid(PlotDimRed(object = sce, color.by = \"Batch\",                                legend.nrow = 1),                    PlotDimRed(object = sce, color.by = \"Species\",                               legend.nrow = 1), ncol = 2)   # Run UMAP set.seed(123) sce <- RunUMAP(sce, dimred.type = \"PCA\")  # Plot results # Plot result  cowplot::plot_grid(PlotDimRed(object = sce, color.by = \"Batch\",                                legend.nrow = 1),                    PlotDimRed(object = sce, color.by = \"Species\",                               legend.nrow = 1), ncol = 2)"},{"path":"https://elolab.github.io/Coralysis/reference/SampleClusterBatchProbs.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample cells based on cluster probabilities distribution batch wise — SampleClusterBatchProbs","title":"Sample cells based on cluster probabilities distribution batch wise — SampleClusterBatchProbs","text":"Samples cells based cluster probabilities distribution batch wise","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SampleClusterBatchProbs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample cells based on cluster probabilities distribution batch wise — SampleClusterBatchProbs","text":"","code":"SampleClusterBatchProbs(cluster, probs, batch, q.split = 0.5)"},{"path":"https://elolab.github.io/Coralysis/reference/SampleClusterBatchProbs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample cells based on cluster probabilities distribution batch wise — SampleClusterBatchProbs","text":"cluster Clustering cell labels predicted ICP (factor). probs Clustering probabilities predicted ICP (matrix). batch Batch labels corresponding clusters (character factor). q.split Split (cell) batch principal component distribution quantile (numeric). default 0.5, .e., median.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SampleClusterBatchProbs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample cells based on cluster probabilities distribution batch wise — SampleClusterBatchProbs","text":"factor cell cluster identities.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SampleClusterProbs.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample cells based on cluster probabilities distribution — SampleClusterProbs","title":"Sample cells based on cluster probabilities distribution — SampleClusterProbs","text":"Samples cells based cluster probabilities distribution","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SampleClusterProbs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample cells based on cluster probabilities distribution — SampleClusterProbs","text":"","code":"SampleClusterProbs(cluster, probs, q.split = 0.5)"},{"path":"https://elolab.github.io/Coralysis/reference/SampleClusterProbs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample cells based on cluster probabilities distribution — SampleClusterProbs","text":"cluster Clustering cell labels predicted ICP (factor). probs Clustering probabilities predicted ICP (matrix). q.split Split (cell) batch principal component distribution quantile (numeric). default 0.5, .e., median.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SampleClusterProbs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample cells based on cluster probabilities distribution — SampleClusterProbs","text":"factor cell cluster identities.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SamplePCACells.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample cells based on principal components distribution — SamplePCACells","title":"Sample cells based on principal components distribution — SamplePCACells","text":"Samples cells based distributions along one principal component","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SamplePCACells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample cells based on principal components distribution — SamplePCACells","text":"","code":"SamplePCACells(   data,   batch = NULL,   q.split = 0.5,   p = 30,   use.pc = \"PC1\",   center = TRUE,   scale. = TRUE )"},{"path":"https://elolab.github.io/Coralysis/reference/SamplePCACells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample cells based on principal components distribution — SamplePCACells","text":"data Data compute PCA sample cells . Rows columns represent cells features, respectively. batch Batch cell label identity (character) matching cells giving data. Use NULL absence batches. batch given cells sampled batch wise manner, otherwise cells sampled without grouping factor. default NULL. q.split Split (cell) batch principal component distribution quantile (numeric). default 0.5, .e., median. p Number principal components compute (integer). default 30. use.pc principal component used sampling cells per batch. default \"PC1\", .e., first principal component used. center features given data centered performing PCA (logical). default TRUE. scale. features given data scaled performing PCA (logical). default TRUE.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SamplePCACells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample cells based on principal components distribution — SamplePCACells","text":"factor cell cluster identities (two clusters).","code":""},{"path":"https://elolab.github.io/Coralysis/reference/Scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale a sparse matrix by row or column — Scale","title":"Scale a sparse matrix by row or column — Scale","text":"Faster implementation scale function. diverges scale function performing root-mean-square scale=TRUE center=FALSE. case divides values standard deviation column row used (depending scale.).","code":""},{"path":"https://elolab.github.io/Coralysis/reference/Scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale a sparse matrix by row or column — Scale","text":"","code":"Scale(x, center = TRUE, scale = TRUE, scale.by = \"col\")"},{"path":"https://elolab.github.io/Coralysis/reference/Scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale a sparse matrix by row or column — Scale","text":"x matrix class `dgCMatrix`. center logical. default TRUE. Subtract values row column mean depending `scale.` parameter. scale logical. default TRUE. Divide values row column standard deviation depending `scale.` parameter scale.Scale `row` `col` (=column), .e., use row column mean /standard deviations center /scale data. Default col.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/Scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale a sparse matrix by row or column — Scale","text":"matrix class `dgCMatrix`.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ScaleByBatch.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale sparse matrix by features (column) by batch — ScaleByBatch","title":"Scale sparse matrix by features (column) by batch — ScaleByBatch","text":"Scales features batch","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ScaleByBatch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale sparse matrix by features (column) by batch — ScaleByBatch","text":"","code":"ScaleByBatch(x, batch)"},{"path":"https://elolab.github.io/Coralysis/reference/ScaleByBatch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale sparse matrix by features (column) by batch — ScaleByBatch","text":"x matrix class `dgCMatrix`. Cells features (rows x columns). batch character vector batch labels corresponding cells given x. character batch labels need named cells names given rows x.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/ScaleByBatch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale sparse matrix by features (column) by batch — ScaleByBatch","text":"scaled matrix class `dgCMatrix`.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SummariseCellClusterProbability.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise ICP cell cluster probability — SummariseCellClusterProbability","title":"Summarise ICP cell cluster probability — SummariseCellClusterProbability","text":"Summarise ICP cell cluster probability table(s)","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SummariseCellClusterProbability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise ICP cell cluster probability — SummariseCellClusterProbability","text":"","code":"SummariseCellClusterProbability.SingleCellExperiment(   object,   icp.run,   icp.round,   funs,   scale.funs,   save.in.sce )  # S4 method for class 'SingleCellExperiment' SummariseCellClusterProbability(   object,   icp.run = NULL,   icp.round = NULL,   funs = c(\"mean\", \"median\"),   scale.funs = TRUE,   save.in.sce = TRUE )"},{"path":"https://elolab.github.io/Coralysis/reference/SummariseCellClusterProbability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise ICP cell cluster probability — SummariseCellClusterProbability","text":"object object SingleCellExperiment class ICP cell cluster probability tables saved metadata(object)$coralysis$joint.probability. running RunParallelDivisiveICP. icp.run ICP run(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved. Specify numeric vector retrieve specific set tables. icp.round ICP round(s) retrieve metadata(object)$coralysis$joint.probability. default NULL, .e., retrieved. funs Functions summarise ICP cell cluster probability: \"mean\" /\"median\". default c(\"mean\", \"median\"), .e, mean median calculated. Set NULL estimate . scale.funs Scale range 0-1 summarised probability obtained funs. default TRUE, .e., summarised probability scaled 0-1 range. save..sce Save data frame cell metadata SingleCellExperiment object return data frame. default TRUE, .e., summary probabilities retrieved save SCE object colData(object).","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SummariseCellClusterProbability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise ICP cell cluster probability — SummariseCellClusterProbability","text":"data frame SingleCellExperiment object ICP cell cluster probability summarised.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/SummariseCellClusterProbability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise ICP cell cluster probability — SummariseCellClusterProbability","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                               colData = DataFrame(\"Species\" = iris$Species,                                                 \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Prepare SCE object for analysis sce <- PrepareData(sce) #> Converting object of `matrix` class into `dgCMatrix`. Please note that Coralysis has been designed to work with sparse data, i.e. data with a high proportion of zero values! Dense data will likely increase run time and memory usage drastically! #> 4/4 features remain after filtering features with only zero values.  # Multi-level integration (just for highlighting purposes; use default parameters) set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"Batch\",                                k = 2, L = 25, C = 1, train.k.nn = 10,                                train.k.nn.prop = NULL, use.cluster.seed = FALSE,                               build.train.set = FALSE, ari.cutoff = 0.1,                               threads = 2) #>  #> Initializing divisive ICP clustering... #>    |                                                                               |                                                                      |   0%   |                                                                               |===                                                                   |   4%   |                                                                               |======                                                                |   8%   |                                                                               |=========                                                             |  12%   |                                                                               |============                                                          |  17%   |                                                                               |===============                                                       |  21%   |                                                                               |==================                                                    |  25%   |                                                                               |====================                                                  |  29%   |                                                                               |=======================                                               |  33%   |                                                                               |==========================                                            |  38%   |                                                                               |=============================                                         |  42%   |                                                                               |================================                                      |  46%   |                                                                               |===================================                                   |  50%   |                                                                               |======================================                                |  54%   |                                                                               |=========================================                             |  58%   |                                                                               |============================================                          |  62%   |                                                                               |===============================================                       |  67%   |                                                                               |==================================================                    |  71%   |                                                                               |====================================================                  |  75%   |                                                                               |=======================================================               |  79%   |                                                                               |==========================================================            |  83%   |                                                                               |=============================================================         |  88%   |                                                                               |================================================================      |  92%   |                                                                               |===================================================================   |  96%   |                                                                               |======================================================================| 100% #>  #> Divisive ICP clustering completed successfully. #>  #> Predicting cell cluster probabilities using ICP models... #> Prediction of cell cluster probabilities completed successfully. #>  #> Multi-level integration completed successfully.                               # Integrated PCA set.seed(125) # to ensure reproducibility for the default 'irlba' method sce <- RunPCA(object = sce, assay.name = \"joint.probability\", p = 10) #> Divisive ICP: selecting ICP tables multiple of 1  # Summarise cluster probability sce <- SummariseCellClusterProbability(object = sce, icp.round = 1,                                         save.in.sce = TRUE) # saved in 'colData'  # Plot the clustering result for ICP run no. 3  PlotDimRed(object = sce, color.by = \"icp_run_round_3_1_clusters\")   # Plot Coralysis mean cell cluster probabilities  PlotExpression(object = sce, color.by = \"mean_probs\",                 color.scale = \"viridis\")"},{"path":"https://elolab.github.io/Coralysis/reference/TabulateCellBinsByGroup.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate cell bins by group — TabulateCellBinsByGroup","title":"Tabulate cell bins by group — TabulateCellBinsByGroup","text":"Frequency cells per cell cluster probability bin group label. label specified beforehand function BinCellClusterProbability().","code":""},{"path":"https://elolab.github.io/Coralysis/reference/TabulateCellBinsByGroup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate cell bins by group — TabulateCellBinsByGroup","text":"","code":"TabulateCellBinsByGroup.SingleCellExperiment(object, group, relative, margin)  # S4 method for class 'SingleCellExperiment' TabulateCellBinsByGroup(object, group, relative = FALSE, margin = 1)"},{"path":"https://elolab.github.io/Coralysis/reference/TabulateCellBinsByGroup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate cell bins by group — TabulateCellBinsByGroup","text":"object object SingleCellExperiment class obtained function BinCellClusterProbability(). group Character specifying colData variable SingleCellExperiment object provided function BinCellClusterProbability() use categorical group variable. relative Logical specifying relative proportions cell bins per group returned. default FALSE, .e., absolute values returned. margin relative TRUE, proportions calculated : rows (1, default); columns (2); overall (NULL).","code":""},{"path":"https://elolab.github.io/Coralysis/reference/TabulateCellBinsByGroup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tabulate cell bins by group — TabulateCellBinsByGroup","text":"list tables frequency cells per bin cell cluster probability group label.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/TabulateCellBinsByGroup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tabulate cell bins by group — TabulateCellBinsByGroup","text":"","code":"if (FALSE) { # \\dontrun{ # Packages suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Import data from Zenodo data.url <- \"https://zenodo.org/records/14845751/files/pbmc_10Xassays.rds?download=1\" sce <- readRDS(file = url(data.url))  # Prepare data sce <- PrepareData(object = sce)  # Multi-level integration - 'L = 4' just for highlighting purposes set.seed(123) sce <- RunParallelDivisiveICP(object = sce, batch.label = \"batch\", L = 4,                                threads = 2)  # Cell states SCE object for a given cell type annotation or clustering cellstate.sce <- BinCellClusterProbability(object = sce, label = \"cell_type\",                                             icp.round = 4, bins = 20)  cellstate.sce  # Tabulate cell bins by group  # give an interesting variable to the \"group\" parameter cellbins.tables <- TabulateCellBinsByGroup(object = cellstate.sce,                                             group = \"batch\",                                             relative = TRUE,                                             margin = 1) } # }"},{"path":"https://elolab.github.io/Coralysis/reference/VlnPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualization of feature expression using violin plots — VlnPlot","title":"Visualization of feature expression using violin plots — VlnPlot","text":"VlnPlot function enables visualizing expression levels feature(s), across clusters using violin plots.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/VlnPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualization of feature expression using violin plots — VlnPlot","text":"","code":"VlnPlot.SingleCellExperiment(   object,   clustering.label,   features,   return.plot,   rotate.x.axis.labels )  # S4 method for class 'SingleCellExperiment' VlnPlot(   object,   clustering.label,   features,   return.plot = FALSE,   rotate.x.axis.labels = FALSE )"},{"path":"https://elolab.github.io/Coralysis/reference/VlnPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualization of feature expression using violin plots — VlnPlot","text":"object SingleCellExperiment class clustering.label variable name (class character) available cell metadata colData(object) clustering labels (character factor) use. features Feature names plot cluster (character) matching row.names(object). return.plot return.plot whether return ggplot2 object. Default FALSE. rotate.x.axis.labels logical denoting whether x-axis labels rotated 90 degrees just draw . Default FALSE.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/VlnPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualization of feature expression using violin plots — VlnPlot","text":"ggplot2 object return.plot=TRUE.","code":""},{"path":"https://elolab.github.io/Coralysis/reference/VlnPlot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualization of feature expression using violin plots — VlnPlot","text":"","code":"# Import package suppressPackageStartupMessages(library(\"SingleCellExperiment\"))  # Create toy SCE data batches <- c(\"b1\", \"b2\") set.seed(239) batch <- sample(x = batches, size = nrow(iris), replace = TRUE) sce <- SingleCellExperiment(assays = list(logcounts = t(iris[,1:4])),                             colData = DataFrame(\"Species\" = iris$Species,                                               \"Batch\" = batch)) colnames(sce) <- paste0(\"samp\", 1:ncol(sce))  # Plot features by clustering/grouping variable VlnPlot(sce, clustering.label = \"Species\",        features = row.names(sce)[1:4],       rotate.x.axis.labels = TRUE)"},{"path":"https://elolab.github.io/Coralysis/news/index.html","id":"coralysis-100","dir":"Changelog","previous_headings":"","what":"Coralysis 1.0.0","title":"Coralysis 1.0.0","text":"First release 🎉 AggregateDataByBatch() RunParallelDivisiveICP() ReferenceMapping() GetCellClusterProbability() SummariseCellClusterProbability() CellClusterProbabilityDistribution() BinCellClusterProbability() TabulateCellBinsByGroup() CellBinsFeatureCorrelation() FindClusterMarkers() FindAllClusterMarkers() MajorityVotingFeatures() RunPCA() RunTSNE() RunUMAP() PCAElbowPlot() PlotDimRed() PlotExpression() PlotClusterTree() VlnPlot() HeatmapFeatures() PrepareData() GetFeatureCoefficients() Integration Reference-mapping","code":""}]
